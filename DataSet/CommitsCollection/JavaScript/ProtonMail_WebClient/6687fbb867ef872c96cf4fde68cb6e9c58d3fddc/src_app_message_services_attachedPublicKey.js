import _ from 'lodash';
import vCard from 'vcf';
import { arrayToBinaryString, decryptMessageLegacy, getFingerprint, getMatchingKey, keyInfo } from 'pmcrypto';

import { VERIFICATION_STATUS, EMAIL_FORMATING, KEY_FLAGS, LARGE_KEY_SIZE, SEND_TYPES } from '../../constants';
import { toList } from '../../../helpers/arrayHelper';
import { getGroup } from '../../../helpers/vcard';
import { normalizeEmail } from '../../../helpers/string';
import { addGetKeys, getKeyAsUri } from '../../../helpers/key';
import { isInternal, getDate } from '../../../helpers/message';
import { getParsedAutocryptHeader } from './autocryptHelper';

const { OPEN_TAG_AUTOCOMPLETE_RAW, CLOSE_TAG_AUTOCOMPLETE_RAW } = EMAIL_FORMATING;
const { SIGNED_AND_INVALID } = VERIFICATION_STATUS;
const MAX_KEY_COUNTS = 5;

/* @ngInject */
function attachedPublicKey(
    contactDetailsModel,
    keyCache,
    keysModel,
    autoPinPrimaryKeys,
    sendPreferences,
    publicKeyStore,
    AttachmentLoader,
    contactEmails,
    Contact,
    networkActivityTracker
) {
    /**
     * Extact and clean the new email
     * Format:
     *     - XXXX <xxx@xxxx.xxx>
     *     - xxx@xxxx.xxx
     * @param  {String} email
     * @return {Object}        { name: String, adr:String }
     */
    const extractAddress = (email) => {
        const [name = '', adr = ''] = email.replace(CLOSE_TAG_AUTOCOMPLETE_RAW, '').split(OPEN_TAG_AUTOCOMPLETE_RAW);
        return { name: name.trim(), adr: adr.trim() };
    };

    /**
     * Transform the userids generated by extractAddress into an object with encrypt and expired values.
     * So we know whether to enable encryption by default and allow enabling encryption.
     * @param keyInfo
     * @param addresses
     * @return {Promise<*[] | never>}
     */
    const populateAddresses = (keyInfo, addresses) => {
        const sendInfo = sendPreferences.get(_.map(addresses, 'adr'));
        const trustedKeys = publicKeyStore.get(_.map(addresses, 'adr'));

        return Promise.all([sendInfo, trustedKeys]).then(([sendPref, publicKeys]) =>
            addresses
                .filter(({ adr }) => publicKeys[adr].every(({ key }) => getFingerprint(key) !== keyInfo.fingerprint))
                .map((address) => {
                    if (keyInfo.expires !== null && keyInfo.expires < Date.now()) {
                        return _.extend({}, address, { encrypt: false, expired: true });
                    }
                    if (sendPref[address.adr].scheme === SEND_TYPES.SEND_PM) {
                        return _.extend({}, address, { encrypt: false });
                    }
                    if (sendPref[address.adr].publickeys.length === 0) {
                        return _.extend({}, address, { encrypt: true });
                    }
                    if (sendPref[address.adr].publickeys[0].getCreationTime() > keyInfo.created) {
                        return _.extend({}, address, { encrypt: false });
                    }
                    return _.extend({}, address, { encrypt: sendPref[address.adr].encrypt });
                })
        );
    };

    /**
     * Extract the sender address from the email. Used when no valid user id could be found in the keys
     * @param Address
     * @param Name
     * @return {{name: *, adr: *}}
     */
    const senderAddress = ({ Sender: { Address, Name } }) => {
        return { name: Name, adr: Address };
    };

    /**
     * Extract the userids from the key, falling back to the message sender if no valid user id could be found.
     * @param message
     * @param keyInfo
     * @return {Promise<*[]|never>}
     */
    const extractAddresses = (message, keyInfo) => {
        const userids = keyInfo.userIds.map(extractAddress).filter(({ adr }) => adr);
        if (!userids.length) {
            return populateAddresses(keyInfo, [senderAddress(message)]);
        }
        return populateAddresses(keyInfo, userids);
    };

    const getPublicKeyFromSig = async (message) => {
        const privateKeys = keysModel.getPrivateKeys(message.AddressID);

        const {
            [message.SenderAddress]: { Keys: keys }
        } = await keyCache.get([message.SenderAddress]);
        const publicKeys = (await addGetKeys(keys, 'PublicKey')).reduce((acc, { Flags, keys }) => {
            if (Flags & KEY_FLAGS.ENABLE_VERIFICATION) {
                acc.push(keys[0]);
            }
            return acc;
        }, []);

        if (publicKeys.length === 0) {
            return false;
        }

        const {
            signatures: [signature = false]
        } = await decryptMessageLegacy({
            message: message.Body,
            messageDate: getDate(message),
            privateKeys,
            publicKeys
        });

        if (!signature) {
            return false;
        }

        const publicKey = await getMatchingKey(signature, publicKeys);

        return publicKey.armor();
    };

    const extractPublicKeysFromAutocrypt = async (message, keyParser) => {
        if (!_.has(message.ParsedHeaders, 'Autocrypt')) {
            return [];
        }
        const autocrypt = toList(message.ParsedHeaders.Autocrypt);
        return _.filter(
            await Promise.all(
                autocrypt.map(async (header) => {
                    const result = getParsedAutocryptHeader(header, message.Sender.Address);
                    if (!result) {
                        return;
                    }
                    return keyParser(result.keydata);
                })
            )
        );
    };

    const keySignsMessage = async (message, keyInfos) => {
        const privateKeys = keysModel.getPrivateKeys(message.AddressID);

        try {
            const { signatures } = await decryptMessageLegacy({
                message: message.Body,
                messageDate: getDate(message),
                privateKeys
            });

            const signaturePackets = _.flatten(
                signatures.map(({ packets }) => Object.values(packets).filter((a) => typeof a === 'object'))
            );

            const signingKeyIds = signaturePackets.map(({ issuerKeyId: { bytes } }) => bytes);

            return (await addGetKeys(keyInfos, 'publicKeyArmored')).filter(({ keys: keyList }) => {
                const keyIds = _.flatten(keyList.map((key) => key.getKeyIds().map(({ bytes }) => bytes)));
                return _.intersection(keyIds, signingKeyIds).length !== 0;
            });
        } catch (e) {
            return [];
        }
    };

    const getMatchingKeyInfo = async (keyInfos, message) => {
        const uniqKeyInfos = _.uniqBy(keyInfos, 'publicKeyArmored');
        if (uniqKeyInfos.length === 1) {
            return uniqKeyInfos[0];
        }
        // only return keys that match with the current message;
        const senderKeyInfos = uniqKeyInfos.filter(({ userIds }) =>
            userIds.some((id) => id.search(`<${message.Sender.Address}>`) !== -1)
        );
        if (senderKeyInfos.length === 1) {
            return senderKeyInfos[0];
        }
        if (senderKeyInfos.length === 0) {
            return false;
        }

        const matchingKeyInfos = await keySignsMessage(message, senderKeyInfos);
        if (matchingKeyInfos.length === 1) {
            return matchingKeyInfos[0];
        }
        return false;
    };

    const extractFromEmail = async (message) => {
        if (isInternal(message)) {
            return message.verified === SIGNED_AND_INVALID ? getPublicKeyFromSig(message) : false;
        }

        const candidates = message.Attachments.filter(
            ({ Name, Size }) => Name.toLowerCase().substring(Name.length - 4) === '.asc' && Size < LARGE_KEY_SIZE
        );

        if (candidates.length > MAX_KEY_COUNTS) {
            return false;
        }

        const keyParser = (key) => {
            return keyInfo(key).catch(() => {
                return false;
            });
        };

        const buffers = (
            await Promise.all(candidates.map((c) => AttachmentLoader.get(c, message).catch(() => false)))
        ).filter(Boolean);
        const armoredFiles = buffers.map(arrayToBinaryString);
        const keyInfos = _.filter(await Promise.all(armoredFiles.map(keyParser)));

        if (keyInfos.length === 0) {
            // try to get them from the autocrypt headers
            keyInfos.push(...(await extractPublicKeysFromAutocrypt(message, keyParser)));
        }

        const keyInfoObject = await getMatchingKeyInfo(keyInfos, message);

        if (!keyInfoObject) {
            return false;
        }
        const addresses = await extractAddresses(message, keyInfoObject);

        const { publicKeyArmored } = keyInfoObject;

        return addresses.length ? publicKeyArmored : false;
    };

    const createContactWithKey = async (publicKey, address) => {
        const group = 'item1';
        const card = new vCard();
        card.set('fn', address.name || address.adr);
        card.set('email', address.adr, { group });
        card.set('key', await getKeyAsUri(publicKey), { group });
        if (address.encrypt) {
            card.set('x-pm-encrypt', 'true', { group });
            card.set('x-pm-sign', 'true', { group });
        }

        return Contact.add([{ vCard: card }]);
    };

    const attachPublicKeyToAddress = async (publicKey, address) => {
        const normalizedEmail = normalizeEmail(address.adr);

        const contactEmail = contactEmails.findEmail(normalizedEmail, normalizeEmail);

        if (!contactEmail) {
            return createContactWithKey(publicKey, address);
        }

        const contact = await Contact.get(contactEmail.ContactID);
        const emailList = toList(contact.vCard.get('email'));
        const group = getGroup(emailList, normalizedEmail);

        const keyList = toList(contact.vCard.data.key || []);
        if (address.encrypt) {
            contact.vCard.add('x-pm-encrypt', 'true', { group });
            contact.vCard.add('x-pm-sign', 'true', { group });
        }

        _.reduce(
            keyList,
            (count, keyProperty) => {
                keyProperty.pref = count;
                return count + 1;
            },
            2
        );

        contact.vCard.add('key', contactDetailsModel.escapeValue(await getKeyAsUri(publicKey)), {
            group,
            pref: address.encrypt ? 1 : keyList.length + 1
        });

        return Contact.updateUnencrypted(contact);
    };

    const attachPublicKeyToAddresses = (publicKey, addresses) => {
        const promise = Promise.all(addresses.map((address) => attachPublicKeyToAddress(publicKey, address))).then(
            () => true
        );
        networkActivityTracker.track(promise);
        return promise;
    };

    const getTransList = (addresses) => {
        const promise = sendPreferences.get(_.map(addresses, 'adr'));
        networkActivityTracker.track(promise);
        return promise;
    };

    const attachPublicKey = async (publicKey, addresses) => {
        const transList = await getTransList(addresses);
        if (_.every(_.map(transList, 'isVerified'))) {
            return attachPublicKeyToAddresses(publicKey, addresses);
        }

        const pairs = _.toPairs(transList);
        const invalidSigs = pairs.filter(([, { isVerified }]) => !isVerified);
        const resigned = await autoPinPrimaryKeys.resign(invalidSigs.map(([adr]) => adr));

        if (!resigned) {
            return false;
        }
        return attachPublicKeyToAddresses(publicKey, addresses);
    };
    return {
        extractAddresses,
        extractFromEmail,
        attachPublicKey
    };
}

export default attachedPublicKey;
