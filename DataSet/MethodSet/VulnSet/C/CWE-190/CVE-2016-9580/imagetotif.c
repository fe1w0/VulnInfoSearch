int imagetotif(opj_image_t * image, const char *outfile)
{
	int width, height;
	int bps,adjust, sgnd;
	int tiPhoto;
	TIFF *tif;
	tdata_t buf;
	tsize_t strip_size;
	OPJ_UINT32 i, numcomps;
	OPJ_SIZE_T rowStride;
	OPJ_INT32* buffer32s = NULL;
	OPJ_INT32 const* planes[4];
	convert_32s_PXCX cvtPxToCx = NULL;
	convert_32sXXx_C1R cvt32sToTif = NULL;

	bps = (int)image->comps[0].prec;
	planes[0] = image->comps[0].data;
	
	numcomps = image->numcomps;
	
	if (image->color_space == OPJ_CLRSPC_CMYK) {
		if (numcomps < 4U) {
			fprintf(stderr,"imagetotif: CMYK images shall be composed of at least 4 planes.\n");
			fprintf(stderr,"\tAborting\n");
			return 1;
		}
		tiPhoto = PHOTOMETRIC_SEPARATED;
		if (numcomps > 4U) {
			numcomps = 4U; /* Alpha not supported */
		}
	}
	else if (numcomps > 2U) {
		tiPhoto = PHOTOMETRIC_RGB;
		if (numcomps > 4U) {
			numcomps = 4U;
		}
	} else {
		tiPhoto = PHOTOMETRIC_MINISBLACK;
	}
	for (i = 1U; i < numcomps; ++i) {
		if (image->comps[0].dx != image->comps[i].dx) {
			break;
		}
		if (image->comps[0].dy != image->comps[i].dy) {
			break;
		}
		if (image->comps[0].prec != image->comps[i].prec) {
			break;
		}
		if (image->comps[0].sgnd != image->comps[i].sgnd) {
			break;
		}
		planes[i] = image->comps[i].data;
	}
	if (i != numcomps) {
		fprintf(stderr,"imagetotif: All components shall have the same subsampling, same bit depth.\n");
		fprintf(stderr,"\tAborting\n");
		return 1;
	}
	
	if(bps > 16) bps = 0;
	if(bps == 0)
	{
		fprintf(stderr,"imagetotif: Bits=%d, Only 1 to 16 bits implemented\n",bps);
		fprintf(stderr,"\tAborting\n");
		return 1;
	}
	tif = TIFFOpen(outfile, "wb");
	if (!tif)
	{
		fprintf(stderr, "imagetotif:failed to open %s for writing\n", outfile);
		return 1;
	}
	for (i = 0U; i < numcomps; ++i) {
		clip_component(&(image->comps[i]), image->comps[0].prec);
	}
	cvtPxToCx = convert_32s_PXCX_LUT[numcomps];
	switch (bps) {
		case 1:
		case 2:
		case 4:
		case 6:
		case 8:
			cvt32sToTif = convert_32sXXu_C1R_LUT[bps];
			break;
		case 3:
			cvt32sToTif = tif_32sto3u;
			break;
		case 5:
			cvt32sToTif = tif_32sto5u;
			break;
		case 7:
			cvt32sToTif = tif_32sto7u;
			break;
		case 9:
			cvt32sToTif = tif_32sto9u;
			break;
		case 10:
			cvt32sToTif = tif_32sto10u;
			break;
		case 11:
			cvt32sToTif = tif_32sto11u;
			break;
		case 12:
			cvt32sToTif = tif_32sto12u;
			break;
		case 13:
			cvt32sToTif = tif_32sto13u;
			break;
		case 14:
			cvt32sToTif = tif_32sto14u;
			break;
		case 15:
			cvt32sToTif = tif_32sto15u;
			break;
		case 16:
			cvt32sToTif = (convert_32sXXx_C1R)tif_32sto16u;
			break;
		default:
			/* never here */
			break;
	}
	sgnd = (int)image->comps[0].sgnd;
	adjust = sgnd ? 1 << (image->comps[0].prec - 1) : 0;
	width   = (int)image->comps[0].w;
	height  = (int)image->comps[0].h;
	
	TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);
	TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);
	TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, numcomps);
	TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);
	TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);
	TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
	TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, tiPhoto);
	TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
	
	strip_size = TIFFStripSize(tif);
	rowStride = ((OPJ_SIZE_T)width * numcomps * (OPJ_SIZE_T)bps + 7U) / 8U;
	if (rowStride != (OPJ_SIZE_T)strip_size) {
		fprintf(stderr, "Invalid TIFF strip size\n");
		TIFFClose(tif);
		return 1;
	}
	buf = _TIFFmalloc(strip_size);
	if (buf == NULL) {
		TIFFClose(tif);
		return 1;
	}
	buffer32s = (OPJ_INT32 *)malloc((OPJ_SIZE_T)width * numcomps * sizeof(OPJ_INT32));
	if (buffer32s == NULL) {
		_TIFFfree(buf);
		TIFFClose(tif);
		return 1;
	}
	
	for (i = 0; i < image->comps[0].h; ++i) {
		cvtPxToCx(planes, buffer32s, (OPJ_SIZE_T)width, adjust);
		cvt32sToTif(buffer32s, (OPJ_BYTE *)buf, (OPJ_SIZE_T)width * numcomps);
		(void)TIFFWriteEncodedStrip(tif, i, (void*)buf, strip_size);
		planes[0] += width;
		planes[1] += width;
		planes[2] += width;
		planes[3] += width;
	}
	_TIFFfree((void*)buf);
	TIFFClose(tif);
	free(buffer32s);
		
	return 0;
}