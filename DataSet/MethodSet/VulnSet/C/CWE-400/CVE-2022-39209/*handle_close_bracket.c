static cmark_node *handle_close_bracket(cmark_parser *parser, subject *subj) {
  bufsize_t initial_pos, after_link_text_pos;
  bufsize_t endurl, starttitle, endtitle, endall;
  bufsize_t sps, n;
  cmark_reference *ref = NULL;
  cmark_chunk url_chunk, title_chunk;
  cmark_chunk url, title;
  bracket *opener;
  cmark_node *inl;
  cmark_chunk raw_label;
  int found_label;
  cmark_node *tmp, *tmpnext;
  bool is_image;

  advance(subj); // advance past ]
  initial_pos = subj->pos;

  // get last [ or ![
  opener = subj->last_bracket;

  if (opener == NULL) {
    return make_str(subj, subj->pos - 1, subj->pos - 1, cmark_chunk_literal("]"));
  }

  if (!opener->active) {
    // take delimiter off stack
    pop_bracket(subj);
    return make_str(subj, subj->pos - 1, subj->pos - 1, cmark_chunk_literal("]"));
  }

  // If we got here, we matched a potential link/image text.
  // Now we check to see if it's a link/image.
  is_image = opener->image;

  after_link_text_pos = subj->pos;

  // First, look for an inline link.
  if (peek_char(subj) == '(' &&
      ((sps = scan_spacechars(&subj->input, subj->pos + 1)) > -1) &&
      ((n = manual_scan_link_url(&subj->input, subj->pos + 1 + sps,
                                 &url_chunk)) > -1)) {

    // try to parse an explicit link:
    endurl = subj->pos + 1 + sps + n;
    starttitle = endurl + scan_spacechars(&subj->input, endurl);

    // ensure there are spaces btw url and title
    endtitle = (starttitle == endurl)
                   ? starttitle
                   : starttitle + scan_link_title(&subj->input, starttitle);

    endall = endtitle + scan_spacechars(&subj->input, endtitle);

    if (peek_at(subj, endall) == ')') {
      subj->pos = endall + 1;

      title_chunk =
          cmark_chunk_dup(&subj->input, starttitle, endtitle - starttitle);
      url = cmark_clean_url(subj->mem, &url_chunk);
      title = cmark_clean_title(subj->mem, &title_chunk);
      cmark_chunk_free(subj->mem, &url_chunk);
      cmark_chunk_free(subj->mem, &title_chunk);
      goto match;

    } else {
      // it could still be a shortcut reference link
      subj->pos = after_link_text_pos;
    }
  }

  // Next, look for a following [link label] that matches in refmap.
  // skip spaces
  raw_label = cmark_chunk_literal("");
  found_label = link_label(subj, &raw_label);
  if (!found_label) {
    // If we have a shortcut reference link, back up
    // to before the spacse we skipped.
    subj->pos = initial_pos;
  }

  if ((!found_label || raw_label.len == 0) && !opener->bracket_after) {
    cmark_chunk_free(subj->mem, &raw_label);
    raw_label = cmark_chunk_dup(&subj->input, opener->position,
                                initial_pos - opener->position - 1);
    found_label = true;
  }

  if (found_label) {
    ref = (cmark_reference *)cmark_map_lookup(subj->refmap, &raw_label);
    cmark_chunk_free(subj->mem, &raw_label);
  }

  if (ref != NULL) { // found
    url = chunk_clone(subj->mem, &ref->url);
    title = chunk_clone(subj->mem, &ref->title);
    goto match;
  } else {
    goto noMatch;
  }

noMatch:
  // If we fall through to here, it means we didn't match a link.
  // What if we're a footnote link?
  if (parser->options & CMARK_OPT_FOOTNOTES &&
      opener->inl_text->next &&
      opener->inl_text->next->type == CMARK_NODE_TEXT) {

    cmark_chunk *literal = &opener->inl_text->next->as.literal;

    // look back to the opening '[', and skip ahead to the next character
    // if we're looking at a '[^' sequence, and there is other text or nodes
    // after the ^, let's call it a footnote reference.
    if ((literal->len > 0 && literal->data[0] == '^') && (literal->len > 1 || opener->inl_text->next->next)) {

      // Before we got this far, the `handle_close_bracket` function may have
      // advanced the current state beyond our footnote's actual closing
      // bracket, ie if it went looking for a `link_label`.
      // Let's just rewind the subject's position:
      subj->pos = initial_pos;

      cmark_node *fnref = make_simple(subj->mem, CMARK_NODE_FOOTNOTE_REFERENCE);

      // the start and end of the footnote ref is the opening and closing brace
      // i.e. the subject's current position, and the opener's start_column
      int fnref_end_column = subj->pos + subj->column_offset + subj->block_offset;
      int fnref_start_column = opener->inl_text->start_column;

      // any given node delineates a substring of the line being processed,
      // with the remainder of the line being pointed to thru its 'literal'
      // struct member.
      // here, we copy the literal's pointer, moving it past the '^' character
      // for a length equal to the size of footnote reference text.
      // i.e. end_col minus start_col, minus the [ and the ^ characters
      //
      // this copies the footnote reference string, even if between the
      // `opener` and the subject's current position there are other nodes
      //
      // (first, check for underflows)
      if ((fnref_start_column + 2) <= fnref_end_column) {
        fnref->as.literal = cmark_chunk_dup(literal, 1, (fnref_end_column - fnref_start_column) - 2);
      } else {
        fnref->as.literal = cmark_chunk_dup(literal, 1, 0);
      }

      fnref->start_line = fnref->end_line = subj->line;
      fnref->start_column = fnref_start_column;
      fnref->end_column = fnref_end_column;

      // we then replace the opener with this new fnref node, the net effect
      // being replacing the opening '[' text node with a `^footnote-ref]` node.
      cmark_node_insert_before(opener->inl_text, fnref);

      process_emphasis(parser, subj, opener->previous_delimiter);
      // sometimes, the footnote reference text gets parsed into multiple nodes
      // i.e. '[^example]' parsed into '[', '^exam', 'ple]'.
      // this happens for ex with the autolink extension. when the autolinker
      // finds the 'w' character, it will split the text into multiple nodes
      // in hopes of being able to match a 'www.' substring.
      //
      // because this function is called one character at a time via the
      // `parse_inlines` function, and the current subj->pos is pointing at the
      // closing ] brace, and because we copy all the text between the [ ]
      // braces, we should be able to safely ignore and delete any nodes after
      // the opener->inl_text->next.
      //
      // therefore, here we walk thru the list and free them all up
      cmark_node *next_node;
      cmark_node *current_node = opener->inl_text->next;
      while(current_node) {
        next_node = current_node->next;
        cmark_node_free(current_node);
        current_node = next_node;
      }

      cmark_node_free(opener->inl_text);

      pop_bracket(subj);
      return NULL;
    }
  }

  pop_bracket(subj); // remove this opener from delimiter list
  subj->pos = initial_pos;
  return make_str(subj, subj->pos - 1, subj->pos - 1, cmark_chunk_literal("]"));

match:
  inl = make_simple(subj->mem, is_image ? CMARK_NODE_IMAGE : CMARK_NODE_LINK);
  inl->as.link.url = url;
  inl->as.link.title = title;
  inl->start_line = inl->end_line = subj->line;
  inl->start_column = opener->inl_text->start_column;
  inl->end_column = subj->pos + subj->column_offset + subj->block_offset;
  cmark_node_insert_before(opener->inl_text, inl);
  // Add link text:
  tmp = opener->inl_text->next;
  while (tmp) {
    tmpnext = tmp->next;
    cmark_node_append_child(inl, tmp);
    tmp = tmpnext;
  }

  // Free the bracket [:
  cmark_node_free(opener->inl_text);

  process_emphasis(parser, subj, opener->previous_delimiter);
  pop_bracket(subj);

  // Now, if we have a link, we also want to deactivate earlier link
  // delimiters. (This code can be removed if we decide to allow links
  // inside links.)
  if (!is_image) {
    opener = subj->last_bracket;
    while (opener != NULL) {
      if (!opener->image) {
        if (!opener->active) {
          break;
        } else {
          opener->active = false;
        }
      }
      opener = opener->previous;
    }
  }

  return NULL;
}