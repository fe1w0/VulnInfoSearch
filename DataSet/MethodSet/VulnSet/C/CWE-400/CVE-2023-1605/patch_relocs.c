static RList *patch_relocs(RBin *b) {
	r_return_val_if_fail (b && b->iob.io && b->iob.io->desc, NULL);
	RBinObject *bo = r_bin_cur_object (b);
	RIO *io = b->iob.io;
	if (!bo || !bo->bin_obj) {
		return NULL;
	}
	struct r_bin_coff_obj *bin = (struct r_bin_coff_obj*)bo->bin_obj;
	if (bin->hdr.f_flags & COFF_FLAGS_TI_F_EXEC) {
		return NULL;
	}
	if (!(io->cached & R_PERM_W)) {
		eprintf (
			"Warning: please run r2 with -e io.cache=true to patch "
			"relocations\n");
		return NULL;
	}

	size_t nimports = 0;
	int i;
	for (i = 0; i < bin->hdr.f_nsyms; i++) {
		if (is_imported_symbol (&bin->symbols[i])) {
			nimports++;
		}
		i += bin->symbols[i].n_numaux;
	}
	ut64 m_vaddr = UT64_MAX;
	if (nimports) {
		ut64 offset = 0;
		RIOBank *bank = b->iob.bank_get (io, io->bank);
		RListIter *iter;
		RIOMapRef *mapref;
		r_list_foreach (bank->maprefs, iter, mapref) {
			RIOMap *map = b->iob.map_get (io, mapref->id);
			if (r_io_map_end (map) > offset) {
				offset = r_io_map_end (map);
			}
		}
		m_vaddr = R_ROUND (offset, 16);
		ut64 size = nimports * BYTES_PER_IMP_RELOC;
		char *muri = r_str_newf ("malloc://%" PFMT64u, size);
		RIODesc *desc = b->iob.open_at (io, muri, R_PERM_R, 0664, m_vaddr);
		free (muri);
		if (!desc) {
			return NULL;
		}

		RIOMap *map = b->iob.map_get_at (io, m_vaddr);
		if (!map) {
			return NULL;
		}
		map->name = strdup (".imports.r2");
	}

	return _relocs_list (b, bin, true, m_vaddr);
}