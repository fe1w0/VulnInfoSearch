R_IPI int wasm_dis(WasmOp *op, const ut8 *buf, int buf_len, bool txt) {
	int id = buf[0];
	if (id < 0xc0) {
		op->type = WASM_TYPE_OP_CORE;
		op->op.core = id;
		op->len = 1;
		WasmOpDef *opdef = &opcodes[id];
		switch (id) {
		case WASM_OP_TRAP:
		case WASM_OP_NOP:
		case WASM_OP_ELSE:
		case WASM_OP_RETURN:
		case WASM_OP_DROP:
		case WASM_OP_SELECT:
		case WASM_OP_I32EQZ:
		case WASM_OP_I32EQ:
		case WASM_OP_I32NE:
		case WASM_OP_I32LTS:
		case WASM_OP_I32LTU:
		case WASM_OP_I32GTS:
		case WASM_OP_I32GTU:
		case WASM_OP_I32LES:
		case WASM_OP_I32LEU:
		case WASM_OP_I32GES:
		case WASM_OP_I32GEU:
		case WASM_OP_I64EQZ:
		case WASM_OP_I64EQ:
		case WASM_OP_I64NE:
		case WASM_OP_I64LTS:
		case WASM_OP_I64LTU:
		case WASM_OP_I64GTS:
		case WASM_OP_I64GTU:
		case WASM_OP_I64LES:
		case WASM_OP_I64LEU:
		case WASM_OP_I64GES:
		case WASM_OP_I64GEU:
		case WASM_OP_F32EQ:
		case WASM_OP_F32NE:
		case WASM_OP_F32LT:
		case WASM_OP_F32GT:
		case WASM_OP_F32LE:
		case WASM_OP_F32GE:
		case WASM_OP_F64EQ:
		case WASM_OP_F64NE:
		case WASM_OP_F64LT:
		case WASM_OP_F64GT:
		case WASM_OP_F64LE:
		case WASM_OP_F64GE:
		case WASM_OP_I32CLZ:
		case WASM_OP_I32CTZ:
		case WASM_OP_I32POPCNT:
		case WASM_OP_I32ADD:
		case WASM_OP_I32SUB:
		case WASM_OP_I32MUL:
		case WASM_OP_I32DIVS:
		case WASM_OP_I32DIVU:
		case WASM_OP_I32REMS:
		case WASM_OP_I32REMU:
		case WASM_OP_I32AND:
		case WASM_OP_I32OR:
		case WASM_OP_I32XOR:
		case WASM_OP_I32SHL:
		case WASM_OP_I32SHRS:
		case WASM_OP_I32SHRU:
		case WASM_OP_I32ROTL:
		case WASM_OP_I32ROTR:
		case WASM_OP_I64CLZ:
		case WASM_OP_I64CTZ:
		case WASM_OP_I64POPCNT:
		case WASM_OP_I64ADD:
		case WASM_OP_I64SUB:
		case WASM_OP_I64MUL:
		case WASM_OP_I64DIVS:
		case WASM_OP_I64DIVU:
		case WASM_OP_I64REMS:
		case WASM_OP_I64REMU:
		case WASM_OP_I64AND:
		case WASM_OP_I64OR:
		case WASM_OP_I64XOR:
		case WASM_OP_I64SHL:
		case WASM_OP_I64SHRS:
		case WASM_OP_I64SHRU:
		case WASM_OP_I64ROTL:
		case WASM_OP_I64ROTR:
		case WASM_OP_F32ABS:
		case WASM_OP_F32NEG:
		case WASM_OP_F32CEIL:
		case WASM_OP_F32FLOOR:
		case WASM_OP_F32TRUNC:
		case WASM_OP_F32NEAREST:
		case WASM_OP_F32SQRT:
		case WASM_OP_F32ADD:
		case WASM_OP_F32SUB:
		case WASM_OP_F32MUL:
		case WASM_OP_F32DIV:
		case WASM_OP_F32MIN:
		case WASM_OP_F32MAX:
		case WASM_OP_F32COPYSIGN:
		case WASM_OP_F64ABS:
		case WASM_OP_F64NEG:
		case WASM_OP_F64CEIL:
		case WASM_OP_F64FLOOR:
		case WASM_OP_F64TRUNC:
		case WASM_OP_F64NEAREST:
		case WASM_OP_F64SQRT:
		case WASM_OP_F64ADD:
		case WASM_OP_F64SUB:
		case WASM_OP_F64MUL:
		case WASM_OP_F64DIV:
		case WASM_OP_F64MIN:
		case WASM_OP_F64MAX:
		case WASM_OP_F64COPYSIGN:
		case WASM_OP_I32WRAPI64:
		case WASM_OP_I32TRUNCSF32:
		case WASM_OP_I32TRUNCUF32:
		case WASM_OP_I32TRUNCSF64:
		case WASM_OP_I32TRUNCUF64:
		case WASM_OP_I64EXTENDSI32:
		case WASM_OP_I64EXTENDUI32:
		case WASM_OP_I64TRUNCSF32:
		case WASM_OP_I64TRUNCUF32:
		case WASM_OP_I64TRUNCSF64:
		case WASM_OP_I64TRUNCUF64:
		case WASM_OP_F32CONVERTSI32:
		case WASM_OP_F32CONVERTUI32:
		case WASM_OP_F32CONVERTSI64:
		case WASM_OP_F32CONVERTUI64:
		case WASM_OP_F32DEMOTEF64:
		case WASM_OP_F64CONVERTSI32:
		case WASM_OP_F64CONVERTUI32:
		case WASM_OP_F64CONVERTSI64:
		case WASM_OP_F64CONVERTUI64:
		case WASM_OP_F64PROMOTEF32:
		case WASM_OP_I32REINTERPRETF32:
		case WASM_OP_I64REINTERPRETF64:
		case WASM_OP_F32REINTERPRETI32:
		case WASM_OP_F64REINTERPRETI64:
		case WASM_OP_END:
			if (txt) {
				op->txt = strdup (opdef->txt);
			}
			break;
		case WASM_OP_BLOCK:
		case WASM_OP_LOOP:
		case WASM_OP_IF:
			{
				st32 val = 0;
				size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);
				if (!(n > 0 && n < buf_len)) {
					goto err;
				}
				if (txt) {
					switch (val) {
					case R_BIN_WASM_VALUETYPE_VOID:
						op->txt = strdup (opdef->txt);
						break;
					case R_BIN_WASM_VALUETYPE_i32:
						op->txt = r_str_newf ("%s (result i32)", opdef->txt);
						break;
					case R_BIN_WASM_VALUETYPE_i64:
						op->txt = r_str_newf ("%s (result i64)", opdef->txt);
						break;
					case R_BIN_WASM_VALUETYPE_f32:
						op->txt = r_str_newf ("%s (result f32)", opdef->txt);
						break;
					case R_BIN_WASM_VALUETYPE_f64:
						op->txt = r_str_newf ("%s (result f64)", opdef->txt);
						break;
					case R_BIN_WASM_VALUETYPE_v128:
						op->txt = r_str_newf ("%s (result v128)", opdef->txt);
						break;
					default:
						op->txt = r_str_newf ("%s (result ?)", opdef->txt);
						break;
					}
				}
				op->len += n;
			}
			break;
		case WASM_OP_BR:
		case WASM_OP_BRIF:
		case WASM_OP_CALL:
			{
				size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &op->val);
				if (n <= 0 || n >= buf_len) {
					goto err;
				}
				if (txt) {
					op->txt = r_str_newf ("%s %d", opdef->txt, op->val);
				}
				op->len += n;
			}
			break;
		case WASM_OP_BRTABLE:
			{
				ut32 count = 0, *table = NULL, def = 0;
				size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);
				if (!(n > 0 && n < buf_len && count < 0xffff)) {
					goto err;
				}
				if (!(table = calloc (count, sizeof (ut32)))) {
					goto err;
				}
				int i = 0;
				op->len += n;
				for (i = 0; i < count; i++) {
					n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);
					if (!(op->len + n <= buf_len)) {
						goto beach;
					}
					if (n < 1) {
						break;
					}
					op->len += n;
				}
				n = read_u32_leb128 (buf + op->len, buf + buf_len, &def);
				if (!(n > 0 && n + op->len < buf_len)) {
					goto beach;
				}
				op->len += n;
				if (txt) {
					RStrBuf *sb = r_strbuf_new ("");
					if (sb) {
						r_strbuf_setf (sb, "%s %d ", opdef->txt, count);
						for (i = 0; i < count; i++) {
							r_strbuf_appendf (sb, "%d ", table[i]);
						}
						r_strbuf_appendf (sb, "%d", def);
						op->txt = r_strbuf_drain (sb);
					}
				}
				free (table);
				break;
			beach:
				free (table);
				goto err;
			}
			break;
		case WASM_OP_CALLINDIRECT:
			{
				ut32 val = 0, reserved = 0;
				size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);
				if (!(n > 0 && n < buf_len)) {
					goto err;
				}
				op->len += n;
				n = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);
				if (!(n == 1 && op->len + n <= buf_len)) {
					goto err;
				}
				reserved &= 0x1;
				if (txt) {
					op->txt = r_str_newf ("%s %d %d", opdef->txt, val, reserved);
				}
				op->len += n;
			}
			break;
		case WASM_OP_GETLOCAL:
		case WASM_OP_SETLOCAL:
		case WASM_OP_TEELOCAL:
		case WASM_OP_GETGLOBAL:
		case WASM_OP_SETGLOBAL:
			{
				ut32 val = 0;
				size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);
				if (!(n > 0 && n < buf_len)) {
					goto err;
				}
				if (txt) {
					op->txt = r_str_newf ("%s %d", opdef->txt, val);
				}
				op->len += n;
			}
			break;
		case WASM_OP_I32LOAD:
		case WASM_OP_I64LOAD:
		case WASM_OP_F32LOAD:
		case WASM_OP_F64LOAD:
		case WASM_OP_I32LOAD8S:
		case WASM_OP_I32LOAD8U:
		case WASM_OP_I32LOAD16S:
		case WASM_OP_I32LOAD16U:
		case WASM_OP_I64LOAD8S:
		case WASM_OP_I64LOAD8U:
		case WASM_OP_I64LOAD16S:
		case WASM_OP_I64LOAD16U:
		case WASM_OP_I64LOAD32S:
		case WASM_OP_I64LOAD32U:
		case WASM_OP_I32STORE:
		case WASM_OP_I64STORE:
		case WASM_OP_F32STORE:
		case WASM_OP_F64STORE:
		case WASM_OP_I32STORE8:
		case WASM_OP_I32STORE16:
		case WASM_OP_I64STORE8:
		case WASM_OP_I64STORE16:
		case WASM_OP_I64STORE32:
			{
				ut32 flag = 0, offset = 0;
				size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);
				if (!(n > 0 && n < buf_len)) {
					goto err;
				}
				op->len += n;
				n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);
				if (!(n > 0 && op->len + n <= buf_len)) {
					goto err;
				}
				if (txt) {
					op->txt = r_str_newf ("%s %d %d", opdef->txt, flag, offset);
				}
				op->len += n;
			}
			break;
		case WASM_OP_CURRENTMEMORY:
		case WASM_OP_GROWMEMORY:
			{
				ut32 reserved = 0;
				size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);
				if (!(n == 1 && n < buf_len)) {
					goto err;
				}
				reserved &= 0x1;
				if (txt) {
					op->txt = r_str_newf ("%s %d", opdef->txt, reserved);
				}
				op->len += n;
			}
			break;
		case WASM_OP_I32CONST:
			{
				st32 val = 0;
				size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);
				if (!(n > 0 && n < buf_len)) {
					goto err;
				}
				if (txt) {
					op->txt = r_str_newf ("%s %" PFMT32d, opdef->txt, val);
				}
				op->len += n;
			}
			break;
		case WASM_OP_I64CONST:
			{
				st64 val = 0;
				size_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);
				if (!(n > 0 && n < buf_len)) {
					goto err;
				}
				if (txt) {
					op->txt = r_str_newf ("%s %" PFMT64d, opdef->txt, val);
				}
				op->len += n;
			}
			break;
		case WASM_OP_F32CONST:
			if (buf_len > 4) {
				union fi {
					ut32  v;
					float f;
				} u;
				u.v = r_read_at_le32 (buf, 1);
				if (txt) {
					op->txt = r_str_newf ("%s %f", opdef->txt, u.f);
				}
				op->len += 4;
			} else {
				goto err;
			}
			break;
		case WASM_OP_F64CONST:
			if (buf_len > 8) {
				union di {
					ut64   v;
					double f;
				} u;
				u.v = r_read_at_le64 (buf, 1);
				if (txt) {
					op->txt = r_str_newf ("%s %f", opdef->txt, u.f);
				}
				op->len += 8;
			} else {
				goto err;
			}
			break;
		default:
			goto err;
		}
	} else if (id == 0xfe) {
		op->type =  WASM_TYPE_OP_ATOMIC;
		if (buf_len < 2) goto err;
		op->len = 2;
		id = buf[1]; // skip 0xfe
		op->op.atomic = id;
		WasmOpDef *opdef = &opcodes_threads[id];
		switch (id) {
		case WASM_OP_I32ATOMICLOAD:
		case WASM_OP_I64ATOMICLOAD:
		case WASM_OP_I32ATOMICLOAD8U:
		case WASM_OP_I32ATOMICLOAD16U:
		case WASM_OP_I64ATOMICLOAD8U:
		case WASM_OP_I64ATOMICLOAD16U:
		case WASM_OP_I64ATOMICLOAD32U:
		case WASM_OP_I32ATOMICSTORE:
		case WASM_OP_I64ATOMICSTORE:
		case WASM_OP_I32ATOMICSTORE8:
		case WASM_OP_I32ATOMICSTORE16:
		case WASM_OP_I64ATOMICSTORE8:
		case WASM_OP_I64ATOMICSTORE16:
		case WASM_OP_I64ATOMICSTORE32:
		case WASM_OP_I32ATOMICRMWADD:
		case WASM_OP_I64ATOMICRMWADD:
		case WASM_OP_I32ATOMICRMW8UADD:
		case WASM_OP_I32ATOMICRMW16UADD:
		case WASM_OP_I64ATOMICRMW8UADD:
		case WASM_OP_I64ATOMICRMW16UADD:
		case WASM_OP_I64ATOMICRMW32UADD:
		case WASM_OP_I32ATOMICRMW8USUB:
		case WASM_OP_I32ATOMICRMW16USUB:
		case WASM_OP_I32ATOMICRMWSUB:
		case WASM_OP_I64ATOMICRMW8USUB:
		case WASM_OP_I64ATOMICRMW16USUB:
		case WASM_OP_I64ATOMICRMW32USUB:
		case WASM_OP_I64ATOMICRMWSUB:
		case WASM_OP_I32ATOMICRMWAND:
		case WASM_OP_I64ATOMICRMWAND:
		case WASM_OP_I32ATOMICRMW8UAND:
		case WASM_OP_I32ATOMICRMW16UAND:
		case WASM_OP_I64ATOMICRMW8UAND:
		case WASM_OP_I64ATOMICRMW16UAND:
		case WASM_OP_I64ATOMICRMW32UAND:
		case WASM_OP_I32ATOMICRMWOR:
		case WASM_OP_I64ATOMICRMWOR:
		case WASM_OP_I32ATOMICRMW8UOR:
		case WASM_OP_I32ATOMICRMW16UOR:
		case WASM_OP_I64ATOMICRMW8UOR:
		case WASM_OP_I64ATOMICRMW16UOR:
		case WASM_OP_I64ATOMICRMW32UOR:
		case WASM_OP_I32ATOMICRMWXOR:
		case WASM_OP_I64ATOMICRMWXOR:
		case WASM_OP_I32ATOMICRMW8UXOR:
		case WASM_OP_I32ATOMICRMW16UXOR:
		case WASM_OP_I64ATOMICRMW8UXOR:
		case WASM_OP_I64ATOMICRMW16UXOR:
		case WASM_OP_I64ATOMICRMW32UXOR:
		case WASM_OP_I32ATOMICRMWXCHG:
		case WASM_OP_I64ATOMICRMWXCHG:
		case WASM_OP_I32ATOMICRMW8UXCHG:
		case WASM_OP_I32ATOMICRMW16UXCHG:
		case WASM_OP_I64ATOMICRMW8UXCHG:
		case WASM_OP_I64ATOMICRMW16UXCHG:
		case WASM_OP_I64ATOMICRMW32UXCHG:
			{
				ut32 flag = 0, offset = 0;
				size_t n = read_u32_leb128 (buf + 2, buf + buf_len, &flag);
				if (!(n > 0 && n < buf_len)) {
					goto err;
				}
				op->len += n;
				n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);
				if (!(n > 0 && op->len + n <= buf_len)) {
					goto err;
				}
				if (txt) {
					op->txt = r_str_newf ("%s %d %d", opdef->txt, flag, offset);
				}
				op->len += n;
			}
			break;
		default:
			goto err;
		}
	} else if (id == 0xfd) {
		if (buf_len < 2) {
			goto err;
		}
		ut32 simdop;
		op->type = WASM_TYPE_OP_SIMD;
		size_t simdop_size = read_u32_leb128 (buf + 1, buf + buf_len, &simdop);
		if (simdop_size > buf_len) {
			goto err;
		}
		op->len = 1 + simdop_size;
		op->op.simd = simdop;
		id = simdop; // this isn't great because we're losing the sign
		// but it should never cause problems
		WasmOpDef *opdef = &opcodes_simd[id];
		switch (id) {
		case WASM_OP_I8X16SPLAT:
		case WASM_OP_I16X8SPLAT:
		case WASM_OP_I32X4SPLAT:
		case WASM_OP_I64X2SPLAT:
		case WASM_OP_F32X4SPLAT:
		case WASM_OP_F64X2SPLAT:
		case WASM_OP_I8X16EQ:
		case WASM_OP_I8X16NE:
		case WASM_OP_I8X16LTS:
		case WASM_OP_I8X16LTU:
		case WASM_OP_I8X16GTS:
		case WASM_OP_I8X16GTU:
		case WASM_OP_I8X16LES:
		case WASM_OP_I8X16LEU:
		case WASM_OP_I8X16GES:
		case WASM_OP_I8X16GEU:
		case WASM_OP_I16X8EQ:
		case WASM_OP_I16X8NE:
		case WASM_OP_I16X8LTS:
		case WASM_OP_I16X8LTU:
		case WASM_OP_I16X8GTS:
		case WASM_OP_I16X8GTU:
		case WASM_OP_I16X8LES:
		case WASM_OP_I16X8LEU:
		case WASM_OP_I16X8GES:
		case WASM_OP_I16X8GEU:
		case WASM_OP_I32X4EQ:
		case WASM_OP_I32X4NE:
		case WASM_OP_I32X4LTS:
		case WASM_OP_I32X4LTU:
		case WASM_OP_I32X4GTS:
		case WASM_OP_I32X4GTU:
		case WASM_OP_I32X4LES:
		case WASM_OP_I32X4LEU:
		case WASM_OP_I32X4GES:
		case WASM_OP_I32X4GEU:
		case WASM_OP_F32X4EQ:
		case WASM_OP_F32X4NE:
		case WASM_OP_F32X4LT:
		case WASM_OP_F32X4GT:
		case WASM_OP_F32X4LE:
		case WASM_OP_F32X4GE:
		case WASM_OP_F64X2EQ:
		case WASM_OP_F64X2NE:
		case WASM_OP_F64X2LT:
		case WASM_OP_F64X2GT:
		case WASM_OP_F64X2LE:
		case WASM_OP_F64X2GE:
		case WASM_OP_V128NOT:
		case WASM_OP_V128AND:
		case WASM_OP_V128OR:
		case WASM_OP_V128XOR:
		case WASM_OP_V128BITSELECT:
		case WASM_OP_I8X16NEG:
		case WASM_OP_I8X16ANYTRUE:
		case WASM_OP_I8X16ALLTRUE:
		case WASM_OP_I8X16SHL:
		case WASM_OP_I8X16SHRS:
		case WASM_OP_I8X16SHRU:
		case WASM_OP_I8X16ADD:
		case WASM_OP_I8X16ADDSATURATES:
		case WASM_OP_I8X16ADDSATURATEU:
		case WASM_OP_I8X16SUB:
		case WASM_OP_I8X16SUBSATURATES:
		case WASM_OP_I8X16SUBSATURATEU:
		case WASM_OP_I8X16MINS:
		case WASM_OP_I8X16MINU:
		case WASM_OP_I8X16MAXS:
		case WASM_OP_I8X16MAXU:
		case WASM_OP_I16X8NEG:
		case WASM_OP_I16X8ANYTRUE:
		case WASM_OP_I16X8ALLTRUE:
		case WASM_OP_I16X8SHL:
		case WASM_OP_I16X8SHRS:
		case WASM_OP_I16X8SHRU:
		case WASM_OP_I16X8ADD:
		case WASM_OP_I16X8ADDSATURATES:
		case WASM_OP_I16X8ADDSATURATEU:
		case WASM_OP_I16X8SUB:
		case WASM_OP_I16X8SUBSATURATES:
		case WASM_OP_I16X8SUBSATURATEU:
		case WASM_OP_I16X8MUL:
		case WASM_OP_I16X8MINS:
		case WASM_OP_I16X8MINU:
		case WASM_OP_I16X8MAXS:
		case WASM_OP_I16X8MAXU:
		case WASM_OP_I32X4NEG:
		case WASM_OP_I32X4ANYTRUE:
		case WASM_OP_I32X4ALLTRUE:
		case WASM_OP_I32X4SHL:
		case WASM_OP_I32X4SHRS:
		case WASM_OP_I32X4SHRU:
		case WASM_OP_I32X4ADD:
		case WASM_OP_I32X4SUB:
		case WASM_OP_I32X4MUL:
		case WASM_OP_I32X4MINS:
		case WASM_OP_I32X4MINU:
		case WASM_OP_I32X4MAXS:
		case WASM_OP_I32X4MAXU:
		case WASM_OP_I64X2NEG:
		case WASM_OP_I64X2SHL:
		case WASM_OP_I64X2SHRS:
		case WASM_OP_I64X2SHRU:
		case WASM_OP_I64X2ADD:
		case WASM_OP_I64X2SUB:
		case WASM_OP_I64X2MUL:
		case WASM_OP_F32X4ABS:
		case WASM_OP_F32X4NEG:
		case WASM_OP_F32X4SQRT:
		case WASM_OP_F32X4ADD:
		case WASM_OP_F32X4SUB:
		case WASM_OP_F32X4MUL:
		case WASM_OP_F32X4DIV:
		case WASM_OP_F32X4MIN:
		case WASM_OP_F32X4MAX:
		case WASM_OP_F64X2ABS:
		case WASM_OP_F64X2NEG:
		case WASM_OP_F64X2SQRT:
		case WASM_OP_F64X2ADD:
		case WASM_OP_F64X2SUB:
		case WASM_OP_F64X2MUL:
		case WASM_OP_F64X2DIV:
		case WASM_OP_F64X2MIN:
		case WASM_OP_F64X2MAX:
		case WASM_OP_I32X4TRUNCSATF32X4S:
		case WASM_OP_I32X4TRUNCSATF32X4U:
		case WASM_OP_F32X4CONVERTI32X4S:
		case WASM_OP_F32X4CONVERTI32X4U:
		case WASM_OP_V8X16SWIZZLE:
		case WASM_OP_I8X16NARROWI16X8S:
		case WASM_OP_I8X16NARROWI16X8U:
		case WASM_OP_I16X8NARROWI32X4S:
		case WASM_OP_I16X8NARROWI32X4U:
		case WASM_OP_I16X8WIDENLOWI8X16S:
		case WASM_OP_I16X8WIDENHIGHI8X16S:
		case WASM_OP_I16X8WIDENLOWI8X16U:
		case WASM_OP_I16X8WIDENHIGHI8X16U:
		case WASM_OP_I32X4WIDENLOWI16X8S:
		case WASM_OP_I32X4WIDENHIGHI16X8S:
		case WASM_OP_I32X4WIDENLOWI16X8U:
		case WASM_OP_I32X4WIDENHIGHI16X8U:
		case WASM_OP_V128ANDNOT:
		case WASM_OP_I8X16AVGRU:
		case WASM_OP_I16X8AVGRU:
		case WASM_OP_I8X16ABS:
		case WASM_OP_I16X8ABS:
		case WASM_OP_I32X4ABS:
			if (txt) {
				op->txt = strdup (opdef->txt);
			}
			break;
		case WASM_OP_V128LOAD:
		case WASM_OP_I16X8LOAD8X8S:
		case WASM_OP_I16X8LOAD8X8U:
		case WASM_OP_I32X4LOAD16X4S:
		case WASM_OP_I32X4LOAD16X4U:
		case WASM_OP_I64X2LOAD32X2S:
		case WASM_OP_I64X2LOAD32X2U:
		case WASM_OP_V8X16LOADSPLAT:
		case WASM_OP_V16X8LOADSPLAT:
		case WASM_OP_V32X4LOADSPLAT:
		case WASM_OP_V64X2LOADSPLAT:
		case WASM_OP_V128STORE:
			{
				ut32 offset = 0, align = 0;
				size_t n = read_u32_leb128 (buf + 1 + simdop_size, buf + buf_len, &offset);
				op->len += n;
				if (!(n > 0 && n < buf_len)) {
					goto err;
				}
				n = read_u32_leb128 (buf + 1 + simdop_size + n, buf + buf_len, &align);
				op->len += n;
				if (!(n > 0 && n < buf_len)) {
					goto err;
				}
				if (txt) {
					op->txt = r_str_newf ("%s o:%d a:2^%d", opdef->txt, offset, align);
				}
			}
			break;
		case WASM_OP_V128CONST:
		case WASM_OP_V8X16SHUFFLE:
			{
				if (buf_len < 18) {
					goto err;
				}
				op->len += 16;
				ut8 bytes[16] = {0};
				int i;
				for (i = 0; i < 16; i++) {
					bytes[i] = buf[i + 1 + simdop_size];
				}
				if (txt) {
					op->txt = r_str_newf ("%s %02x %02x %02x %02x %02x %02x %02x " \
						"%02x %02x %02x %02x %02x %02x %02x %02x %02x",
						opdef->txt, bytes[0], bytes[1], bytes[2], bytes[3],
						bytes[4], bytes[5], bytes[6], bytes[7], bytes[8],
						bytes[9], bytes[10], bytes[11], bytes[12], bytes[13],
						bytes[14], bytes[15]);
				}
			}
			break;
		case WASM_OP_I8X16EXTRACTLANES:
		case WASM_OP_I8X16EXTRACTLANEU:
		case WASM_OP_I8X16REPLACELANE:
		case WASM_OP_I16X8EXTRACTLANES:
		case WASM_OP_I16X8EXTRACTLANEU:
		case WASM_OP_I16X8REPLACELANE:
		case WASM_OP_I32X4EXTRACTLANE:
		case WASM_OP_I32X4REPLACELANE:
		case WASM_OP_I64X2EXTRACTLANE:
		case WASM_OP_I64X2REPLACELANE:
		case WASM_OP_F32X4EXTRACTLANE:
		case WASM_OP_F32X4REPLACELANE:
		case WASM_OP_F64X2EXTRACTLANE:
		case WASM_OP_F64X2REPLACELANE:
			{
				if (buf_len < 3) {
					goto err;
				}
				unsigned char lane = buf[1 + simdop_size];
				++op->len;
				if (txt) {
					op->txt = r_str_newf ("%s %d", opdef->txt, lane);
				}
			}
			break;
		}
	} else {
		goto err;
	}
	return op->len;

  err:
	op->len = 1;
	if (txt) {
		op->txt = strdup ("invalid");
	}
	return op->len;
}