    void
scrolldown(
    long	line_count,
    int		byfold UNUSED)	// TRUE: count a closed fold as one line
{
    long	done = 0;	// total # of physical lines done
    int		wrow;
    int		moved = FALSE;
    int		do_sms = curwin->w_p_wrap && curwin->w_p_sms;
    int		width1 = 0;
    int		width2 = 0;

    if (do_sms)
    {
	width1 = curwin->w_width - curwin_col_off();
	width2 = width1 + curwin_col_off2();
    }

#ifdef FEAT_FOLDING
    linenr_T	first;

    // Make sure w_topline is at the first of a sequence of folded lines.
    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
#endif
    validate_cursor();		// w_wrow needs to be valid
    for (int todo = line_count; todo > 0; --todo)
    {
#ifdef FEAT_DIFF
	if (curwin->w_topfill < diff_check(curwin, curwin->w_topline)
		&& curwin->w_topfill < curwin->w_height - 1)
	{
	    ++curwin->w_topfill;
	    ++done;
	}
	else
#endif
	{
	    // break when at the very top
	    if (curwin->w_topline == 1
				   && (!do_sms || curwin->w_skipcol < width1))
		break;
	    if (do_sms && curwin->w_skipcol >= width1)
	    {
		// scroll a screen line down
		if (curwin->w_skipcol >= width1 + width2)
		    curwin->w_skipcol -= width2;
		else
		    curwin->w_skipcol -= width1;
		redraw_later(UPD_NOT_VALID);
		++done;
	    }
	    else
	    {
		// scroll a text line down
		--curwin->w_topline;
		curwin->w_skipcol = 0;
#ifdef FEAT_DIFF
		curwin->w_topfill = 0;
#endif
#ifdef FEAT_FOLDING
		// A sequence of folded lines only counts for one logical line
		if (hasFolding(curwin->w_topline, &first, NULL))
		{
		    ++done;
		    if (!byfold)
			todo -= curwin->w_topline - first - 1;
		    curwin->w_botline -= curwin->w_topline - first;
		    curwin->w_topline = first;
		}
		else
#endif
		if (do_sms)
		{
		    int size = win_linetabsize(curwin, curwin->w_topline,
				   ml_get(curwin->w_topline), (colnr_T)MAXCOL);
		    if (size > width1)
		    {
			curwin->w_skipcol = width1;
			size -= width1;
			redraw_later(UPD_NOT_VALID);
		    }
		    while (size > width2)
		    {
			curwin->w_skipcol += width2;
			size -= width2;
		    }
		    ++done;
		}
		else
		    done += PLINES_NOFILL(curwin->w_topline);
	    }
	}
	--curwin->w_botline;		// approximate w_botline
	invalidate_botline();
    }
    curwin->w_wrow += done;		// keep w_wrow updated
    curwin->w_cline_row += done;	// keep w_cline_row updated

#ifdef FEAT_DIFF
    if (curwin->w_cursor.lnum == curwin->w_topline)
	curwin->w_cline_row = 0;
    check_topfill(curwin, TRUE);
#endif

    /*
     * Compute the row number of the last row of the cursor line
     * and move the cursor onto the displayed part of the window.
     */
    wrow = curwin->w_wrow;
    if (curwin->w_p_wrap && curwin->w_width != 0)
    {
	validate_virtcol();
	validate_cheight();
	wrow += curwin->w_cline_height - 1 -
	    curwin->w_virtcol / curwin->w_width;
    }
    while (wrow >= curwin->w_height && curwin->w_cursor.lnum > 1)
    {
#ifdef FEAT_FOLDING
	if (hasFolding(curwin->w_cursor.lnum, &first, NULL))
	{
	    --wrow;
	    if (first == 1)
		curwin->w_cursor.lnum = 1;
	    else
		curwin->w_cursor.lnum = first - 1;
	}
	else
#endif
	    wrow -= plines(curwin->w_cursor.lnum--);
	curwin->w_valid &=
	      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);
	moved = TRUE;
    }
    if (moved)
    {
#ifdef FEAT_FOLDING
	// Move cursor to first line of closed fold.
	foldAdjustCursor();
#endif
	coladvance(curwin->w_curswant);
    }

    if (curwin->w_cursor.lnum == curwin->w_topline && do_sms)
    {
	long	so = get_scrolloff_value();
	int	scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;

	// make sure the cursor is in the visible text
	validate_virtcol();
	int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;
	int row = 0;
	if (col >= width1)
	{
	    col -= width1;
	    ++row;
	}
	if (col > width2)
	{
	    row += col / width2;
	    col = col % width2;
	}
	if (row >= curwin->w_height)
	{
	    curwin->w_curswant = curwin->w_virtcol
				       - (row - curwin->w_height + 1) * width2;
	    coladvance(curwin->w_curswant);
	}
    }
}