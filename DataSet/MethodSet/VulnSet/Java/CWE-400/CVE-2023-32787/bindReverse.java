	public void bindReverse(final SocketAddress addressToConnect,
			final String endpointUrl) {
		if(addressToConnect == null || endpointUrl == null) {
			throw new IllegalArgumentException();
		}
		init();
		
		ReverseSocketHandle socketHandle = new ReverseSocketHandle(addressToConnect);
		if(socketHandle.socket == null) {
			try {
				socketHandle.setChannel(SocketChannel.open());
				socketHandle.getChannel().configureBlocking(false);
				
				socketHandle.socket = new AsyncSocketImpl(socketHandle.getChannel(), StackUtils.getNonBlockingWorkExecutor(), StackUtils.getSelector());

				ReverseHello rh = new ReverseHello();
				rh.setEndpointUrl(endpointUrl);
				rh.setServerUri(application.getApplicationDescription().getApplicationUri());
				final OpcTcpServerConnection conn = new OpcTcpServerConnection(OpcTcpServer.this, socketHandle.socket, rh); 
				connections.addConnection(conn);
				
				conn.addConnectionListener(new IConnectionListener() {
					@Override
					public void onClosed(ServiceResultException closeError) {						
						connections.removeConnection(conn);
							
						//1.04 Part 6 section 7.1.3 when closed, server must restart the process
						logger.debug("ReverseHello connection closed, rescheduling connection process");
						bindReverse(addressToConnect, endpointUrl);
					}
					@Override
					public void onOpen() {
					}});
				//async, do last, others listen on socket state.
				socketHandle.socket.connect(socketHandle.socketAddress);
			}catch(IOException e) {
				logger.error("Failed to create a ReverseSocketHandle", e);
				socketHandle.close();
			}
			
		}