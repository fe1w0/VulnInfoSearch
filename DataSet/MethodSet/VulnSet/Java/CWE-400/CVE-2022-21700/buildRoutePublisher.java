class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {
    public Flowable<MutableHttpResponse<?>> buildRoutePublisher(
            Class<?> declaringType,
            ReturnType<?> genericReturnType,
            boolean isReactiveReturnType,
            AnnotationMetadata annotationMetadata,
            AtomicReference<HttpRequest<?>> requestReference,
            Flowable<MutableHttpResponse<?>> routePublisher) {
        // In the case of an empty reactive type we switch handling so that
        // a 404 NOT_FOUND is returned
        routePublisher = routePublisher.switchIfEmpty(Flowable.create((emitter) -> {
            HttpRequest<?> httpRequest = requestReference.get();
            MutableHttpResponse<?> response;
            Class<?> javaReturnType = genericReturnType.getType();
            boolean isVoid = javaReturnType == void.class ||
                    Completable.class.isAssignableFrom(javaReturnType) ||
                    (isReactiveReturnType && genericReturnType.getFirstTypeVariable()
                            .filter(arg -> arg.getType() == Void.class).isPresent());

            if (isVoid) {
                // void return type with no response, nothing else to do
                response = forStatus(annotationMetadata);
            } else {
                // handle re-mapping of errors
                Optional<RouteMatch<Object>> statusRoute = Optional.empty();
                // if declaringType is not null, this means its a locally marked method handler
                if (declaringType != null) {
                    statusRoute = router.route(declaringType, HttpStatus.NOT_FOUND);
                }
                if (!statusRoute.isPresent()) {
                    statusRoute = router.route(HttpStatus.NOT_FOUND);
                }

                if (statusRoute.isPresent()) {
                    RouteMatch<?> newRoute = requestArgumentSatisfier.fulfillArgumentRequirements(statusRoute.get(), httpRequest, true);

                    if (newRoute.isExecutable()) {
                        try {
                            Object result = newRoute.execute();
                            response = messageToResponse(newRoute, result);
                        } catch (Throwable e) {
                            emitter.onError(new InternalServerException("Error executing status route [" + newRoute + "]: " + e.getMessage(), e));
                            return;
                        }

                    } else {
                        if (LOG.isWarnEnabled()) {
                            LOG.warn("Matched status route [" + newRoute + "] not executed because one or more arguments could not be bound. Returning a default response.");
                        }
                        response = newNotFoundError(httpRequest);
                    }
                    response.setAttribute(HttpAttributes.ROUTE_MATCH, newRoute);
                } else {
                    response = newNotFoundError(httpRequest);
                }
            }

            try {
                emitter.onNext(response);
                emitter.onComplete();
            } catch (Throwable e) {
                emitter.onError(new InternalServerException("Error executing Error route [" + response.getStatus() + "]: " + e.getMessage(), e));
            }
        }, BackpressureStrategy.ERROR));
        return routePublisher;
    }
}