class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {
    public void streamHttpContentChunkByChunk(
        ChannelHandlerContext context,
        NettyHttpRequest<?> request,
        FullHttpResponse nativeResponse,
        MediaType mediaType,
        boolean isJson,
        Publisher<Object> publisher) {

        NettyByteBufferFactory byteBufferFactory = new NettyByteBufferFactory(context.alloc());

        Publisher<HttpContent> httpContentPublisher = Publishers.map(publisher, new Function<Object, HttpContent>() {
            boolean first = true;

            @Override
            public HttpContent apply(Object message) {
                HttpContent httpContent;
                if (message instanceof ByteBuf) {
                    httpContent = new DefaultHttpContent((ByteBuf) message);
                } else if (message instanceof ByteBuffer) {
                    ByteBuffer byteBuffer = (ByteBuffer) message;
                    Object nativeBuffer = byteBuffer.asNativeBuffer();
                    if (nativeBuffer instanceof ByteBuf) {
                        httpContent = new DefaultHttpContent((ByteBuf) nativeBuffer);
                    } else {
                        httpContent = new DefaultHttpContent(Unpooled.copiedBuffer(byteBuffer.asNioBuffer()));
                    }
                } else if (message instanceof byte[]) {
                    httpContent = new DefaultHttpContent(Unpooled.copiedBuffer((byte[]) message));
                } else if (message instanceof HttpContent) {
                    httpContent = (HttpContent) message;
                } else {

                    MediaTypeCodec codec = mediaTypeCodecRegistry.findCodec(mediaType, message.getClass()).orElse(
                        new TextPlainCodec(serverConfiguration.getDefaultCharset()));

                    if (LOG.isDebugEnabled()) {
                        LOG.debug("Encoding emitted response object [{}] using codec: {}", message, codec);
                    }
                    ByteBuffer encoded = codec.encode(message, byteBufferFactory);
                    httpContent = new DefaultHttpContent((ByteBuf) encoded.asNativeBuffer());
                }
                if (!isJson || first) {
                    first = false;
                    return httpContent;
                } else {
                    return HttpContentUtil.prefixComma(httpContent);
                }
            }
        });

        if (isJson && !Publishers.isSingle(publisher.getClass())) {
            // if the Publisher is returning JSON then in order for it to be valid JSON for each emitted element
            // we must wrap the JSON in array and delimit the emitted items
            httpContentPublisher = Flowable.concat(
                Flowable.fromCallable(HttpContentUtil::openBracket),
                httpContentPublisher,
                Flowable.fromCallable(HttpContentUtil::closeBracket)
            );
        }

        if (mediaType.equals(MediaType.TEXT_EVENT_STREAM_TYPE)) {
            httpContentPublisher = Publishers.onComplete(httpContentPublisher, () -> {
                CompletableFuture<Void> future = new CompletableFuture<>();
                if (request == null || !request.getHeaders().isKeepAlive()) {
                    if (context.channel().isOpen()) {
                        context.pipeline()
                            .writeAndFlush(new DefaultLastHttpContent())
                            .addListener(f -> {
                                    if (f.isSuccess()) {
                                        future.complete(null);
                                    } else {
                                        future.completeExceptionally(f.cause());
                                    }
                                }
                            );
                    }
                }
                return future;
            });
        }

        httpContentPublisher = Publishers.then(httpContentPublisher, httpContent -> {
            // once an http content is written, read the next item if it is available
            context.read();
        });

        DelegateStreamedHttpResponse streamedResponse = new DelegateStreamedHttpResponse(nativeResponse, httpContentPublisher);
        io.netty.handler.codec.http.HttpHeaders headers = streamedResponse.headers();
        headers.add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
        headers.add(HttpHeaderNames.CONTENT_TYPE, mediaType);
        context.writeAndFlush(streamedResponse);
        context.read();
    }
}