class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {
    public static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);
    public static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(
    public final Router router;
    public final ExecutorSelector executorSelector;
    public final StaticResourceResolver staticResourceResolver;
    public final ExecutorService ioExecutor;
    public final BeanLocator beanLocator;
    public final NettyHttpServerConfiguration serverConfiguration;
    public final RequestArgumentSatisfier requestArgumentSatisfier;
    public final MediaTypeCodecRegistry mediaTypeCodecRegistry;
    public final NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry;
    public void subscribeToResponsePublisher(
            ChannelHandlerContext context,
            MediaType defaultResponseMediaType,
            AtomicReference<HttpRequest<?>> requestReference,
            Flowable<? extends MutableHttpResponse<?>> finalPublisher) {
        finalPublisher =  finalPublisher.map((response) -> {
            Optional<MediaType> specifiedMediaType = response.getContentType();
            MediaType responseMediaType = specifiedMediaType.orElse(defaultResponseMediaType);

            applyConfiguredHeaders(response.getHeaders());

            Optional<?> responseBody = response.getBody();
            if (responseBody.isPresent()) {

                Object body = responseBody.get();

                Optional<NettyCustomizableResponseTypeHandler> typeHandler = customizableResponseTypeHandlerRegistry
                        .findTypeHandler(body.getClass());
                if (typeHandler.isPresent()) {
                    NettyCustomizableResponseTypeHandler th = typeHandler.get();
                    setBodyContent(response, new NettyCustomizableResponseTypeHandlerInvoker(th, body));
                    return response;
                }

                if (specifiedMediaType.isPresent())  {

                    Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(responseMediaType, body.getClass());
                    if (registeredCodec.isPresent()) {
                        MediaTypeCodec codec = registeredCodec.get();
                        return encodeBodyWithCodec(response, body, codec, responseMediaType, context, requestReference);
                    }
                }

                Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(defaultResponseMediaType, body.getClass());
                if (registeredCodec.isPresent()) {
                    MediaTypeCodec codec = registeredCodec.get();
                    return encodeBodyWithCodec(response, body, codec, responseMediaType, context, requestReference);
                }

                MediaTypeCodec defaultCodec = new TextPlainCodec(serverConfiguration.getDefaultCharset());

                return encodeBodyWithCodec(response, body, defaultCodec, responseMediaType,  context, requestReference);
            } else {
                return response;
            }
        });

        finalPublisher.subscribe(new ContextCompletionAwareSubscriber<MutableHttpResponse<?>>(context) {
            @Override
            protected void onComplete(MutableHttpResponse<?> message) {
                writeFinalNettyResponse(message, requestReference, context);
            }

            @Override
            protected void doOnError(Throwable t) {
                exceptionCaughtInternal(context, t, (NettyHttpRequest) requestReference.get(), false);
            }
        });
    }
}