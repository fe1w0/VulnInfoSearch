public class DTLSConnector implements Connector, RecordLayer {
	public static final String KEY_TLS_SERVER_HOST_NAME = "TLS_SERVER_HOST_NAME";
	public static final Logger LOGGER = LoggerFactory.getLogger(DTLSConnector.class);
	public static final Logger DROP_LOGGER = LoggerFactory.getLogger(LOGGER.getName() + ".drops");
	public static final int MAX_PLAINTEXT_FRAGMENT_LENGTH = 16384; // max. DTLSPlaintext.length (2^14 bytes)
	public static final int MAX_CIPHERTEXT_EXPANSION = CipherSuite.getOverallMaxCiphertextExpansion();
	public static final int MAX_DATAGRAM_BUFFER_SIZE = MAX_PLAINTEXT_FRAGMENT_LENGTH
	public static final int TLS12_CID_PADDING = 0;
	public static final long CLIENT_HELLO_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(60);
	public static final boolean MDC_SUPPORT;
	public final DtlsConnectorConfig config;
	public final ResumptionSupportingConnectionStore connectionStore;
	public final Long autoResumptionTimeoutMillis;
	public final int thresholdHandshakesWithoutVerifiedPeer;
	public final AtomicInteger pendingHandshakesWithoutVerifiedPeer = new AtomicInteger();
	public final DtlsHealth health;
	public final boolean serverOnly;
	public final String defaultHandshakeMode;
	public final int useExtendedWindowFilter;
	public final boolean useFilter;
	public final boolean useCidUpdateAddressOnNewerRecordFilter;
	public final AtomicInteger pendingOutboundMessagesCountdown = new AtomicInteger();
	public final List<Thread> receiverThreads = new LinkedList<Thread>();
	public final ConnectionIdGenerator connectionIdGenerator;
	public final ProtocolVersion protocolVersionForHelloVerifyRequests;
	public ScheduledFuture<?> statusLogger;
	public InetSocketAddress lastBindAddress;
	public Integer maximumTransmissionUnit;
	public int ipv4Mtu = DEFAULT_IPV4_MTU;
	public int ipv6Mtu = DEFAULT_IPV6_MTU;
	public int inboundDatagramBufferSize = MAX_DATAGRAM_BUFFER_SIZE;
	public CookieGenerator cookieGenerator = new CookieGenerator();
	public Object alertHandlerLock= new Object();
	public volatile DatagramSocket socket;
	public ScheduledExecutorService timer;
	public AtomicBoolean running = new AtomicBoolean(false);
	public volatile EndpointContextMatcher endpointContextMatcher;
	public volatile RawDataChannel messageHandler;
	public AlertHandler alertHandler;
	public SessionListener sessionListener;
	public ConnectionExecutionListener connectionExecutionListener;
	public ExecutorService executorService;
	public boolean hasInternalExecutor;
	public void processDatagram(DatagramPacket packet, InetSocketAddress router) {
		InetSocketAddress peerAddress = (InetSocketAddress) packet.getSocketAddress();
		if (MDC_SUPPORT) {
			MDC.put("PEER", StringUtil.toString(peerAddress));
		}
		if (health != null) {
			health.receivingRecord(false);
		}
		long timestamp = ClockUtil.nanoRealtime();

		if (peerAddress.getPort() == 0) {
			// RFC 768
			// Source Port is an optional field, when meaningful, it indicates
			// the port of the sending process, and may be assumed to be the
			// port to which a reply should be addressed in the absence of any
			// other information. If not used, a value of zero is inserted.
			DROP_LOGGER.trace("Discarding record with {} bytes from [{}] without source-port", packet.getLength(),
					peerAddress);
			if (health != null) {
				health.receivingRecord(true);
			}
			return;
		}
		DatagramReader reader = new DatagramReader(packet.getData(), packet.getOffset(), packet.getLength());
		List<Record> records = Record.fromReader(reader, peerAddress, router, connectionIdGenerator, timestamp);
		LOGGER.trace("Received {} DTLS records from {} using a {} byte datagram buffer",
				records.size(), peerAddress, inboundDatagramBufferSize);

		if (records.isEmpty()) {
			DROP_LOGGER.trace("Discarding {} malicious record with {} bytes from [{}]", packet.getLength(), peerAddress);
			if (health != null) {
				health.receivingRecord(true);
			}
			return;
		}

		if (!running.get()) {
			DROP_LOGGER.trace("Discarding {} records, startting with {} from [{}] on shutdown", records.size(),
					records.get(0).getType(), peerAddress);
			LOGGER.debug("Execution shutdown while processing incoming records from peer: {}", peerAddress);
			if (health != null) {
				health.receivingRecord(true);
			}
			return;
		}

		final Record firstRecord = records.get(0);

		if (records.size() == 1 && firstRecord.isNewClientHello()) {
			getExecutorService().execute(new Runnable() {

				@Override
				public void run() {
					if (MDC_SUPPORT) {
						MDC.put("PEER", StringUtil.toString(firstRecord.getPeerAddress()));
					}
					processNewClientHello(firstRecord);
					if (MDC_SUPPORT) {
						MDC.clear();
					}
				}
			});
			return;
		}

		final ConnectionId connectionId = firstRecord.getConnectionId();
		final Connection connection = getConnection(peerAddress, connectionId, false);

		if (connection == null) {
			if (health != null) {
				health.receivingRecord(true);
			}
			if (connectionId == null) {
				DROP_LOGGER.trace("Discarding {} records from [{}] received without existing connection",
						records.size(), peerAddress);
			} else {
				DROP_LOGGER.trace("Discarding {} records from [{},{}] received without existing connection",
						records.size(), peerAddress, connectionId);
			}
			return;
		}

		SerialExecutor serialExecutor = connection.getExecutor();

		for (final Record record : records) {
			try {

				serialExecutor.execute(new Runnable() {

					@Override
					public void run() {
						if (running.get()) {
							processRecord(record, connection);
						}
					}
				});
			} catch (RejectedExecutionException e) {
				// dont't terminate connection on shutdown!
				LOGGER.debug("Execution rejected while processing record [type: {}, peer: {}]",
						record.getType(), peerAddress, e);
				break;
			} catch (RuntimeException e) {
				LOGGER.warn("Unexpected error occurred while processing record [type: {}, peer: {}]",
						record.getType(), peerAddress, e);
				terminateConnection(connection, e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);
				break;
			}
		}
	}
}