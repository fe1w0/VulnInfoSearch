public class DTLSConnector implements Connector, RecordLayer {
	public static final String KEY_TLS_SERVER_HOST_NAME = "TLS_SERVER_HOST_NAME";
	private static final Logger LOGGER = LoggerFactory.getLogger(DTLSConnector.class);
	private static final Logger DROP_LOGGER = LoggerFactory.getLogger(LOGGER.getName() + ".drops");
	private static final int MAX_PLAINTEXT_FRAGMENT_LENGTH = 16384; // max. DTLSPlaintext.length (2^14 bytes)
	private static final int MAX_CIPHERTEXT_EXPANSION = CipherSuite.getOverallMaxCiphertextExpansion();
	private static final int MAX_DATAGRAM_BUFFER_SIZE = MAX_PLAINTEXT_FRAGMENT_LENGTH
	private static final int TLS12_CID_PADDING = 0;
	private static final long CLIENT_HELLO_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(60);
	private static final boolean MDC_SUPPORT;
	protected final DtlsConnectorConfig config;
	private final ResumptionSupportingConnectionStore connectionStore;
	private final Long autoResumptionTimeoutMillis;
	private final int thresholdHandshakesWithoutVerifiedPeer;
	private final AtomicInteger pendingHandshakesWithoutVerifiedPeer = new AtomicInteger();
	protected final DtlsHealth health;
	private final boolean serverOnly;
	private final String defaultHandshakeMode;
	private final int useExtendedWindowFilter;
	private final boolean useFilter;
	private final boolean useCidUpdateAddressOnNewerRecordFilter;
	private final AtomicInteger pendingOutboundMessagesCountdown = new AtomicInteger();
	private final List<Thread> receiverThreads = new LinkedList<Thread>();
	protected final ConnectionIdGenerator connectionIdGenerator;
	private final ProtocolVersion protocolVersionForHelloVerifyRequests;
	private ScheduledFuture<?> statusLogger;
	private InetSocketAddress lastBindAddress;
	private Integer maximumTransmissionUnit;
	private int ipv4Mtu = DEFAULT_IPV4_MTU;
	private int ipv6Mtu = DEFAULT_IPV6_MTU;
	protected int inboundDatagramBufferSize = MAX_DATAGRAM_BUFFER_SIZE;
	private CookieGenerator cookieGenerator = new CookieGenerator();
	private Object alertHandlerLock= new Object();
	private volatile DatagramSocket socket;
	protected ScheduledExecutorService timer;
	private AtomicBoolean running = new AtomicBoolean(false);
	private volatile EndpointContextMatcher endpointContextMatcher;
	private volatile RawDataChannel messageHandler;
	private AlertHandler alertHandler;
	private SessionListener sessionListener;
	private ConnectionExecutionListener connectionExecutionListener;
	private ExecutorService executorService;
	private boolean hasInternalExecutor;
	private void processAsynchronousHandshakeResult(final HandshakeResult handshakeResult) {
		final Connection connection = connectionStore.get(handshakeResult.getConnectionId());
		if (connection != null && connection.hasOngoingHandshake()) {
			SerialExecutor serialExecutor = connection.getExecutor();

			try {

				serialExecutor.execute(new Runnable() {

					@Override
					public void run() {
						if (running.get()) {
							Handshaker handshaker = connection.getOngoingHandshake();
							if (handshaker != null) {
								try {
									handshaker.processAsyncHandshakeResult(handshakeResult);
								} catch (HandshakeException e) {
									handleExceptionDuringHandshake(e, connection, null);
								} catch (IllegalStateException e) {
									LOGGER.warn("Exception while processing handshake result [{}]", connection, e);
								}
							} else {
								LOGGER.debug("No ongoing handshake for result [{}]", connection);
							}
						} else {
							LOGGER.debug("Execution stopped while processing handshake result [{}]", connection);
						}
					}
				});
			} catch (RejectedExecutionException e) {
				// dont't terminate connection on shutdown!
				LOGGER.debug("Execution rejected while processing handshake result [{}]", connection, e);
			} catch (RuntimeException e) {
				LOGGER.warn("Unexpected error occurred while processing handshake result [{}]", connection, e);
			}
		} else {
			LOGGER.debug("No connection or ongoing handshake for handshake result [{}]", connection);
		}
	}
}