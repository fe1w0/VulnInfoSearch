public class DTLSConnector implements Connector, RecordLayer {
	public static final String KEY_TLS_SERVER_HOST_NAME = "TLS_SERVER_HOST_NAME";
	private static final Logger LOGGER = LoggerFactory.getLogger(DTLSConnector.class);
	private static final Logger DROP_LOGGER = LoggerFactory.getLogger(LOGGER.getName() + ".drops");
	private static final int MAX_PLAINTEXT_FRAGMENT_LENGTH = 16384; // max. DTLSPlaintext.length (2^14 bytes)
	private static final int MAX_CIPHERTEXT_EXPANSION = CipherSuite.getOverallMaxCiphertextExpansion();
	private static final int MAX_DATAGRAM_BUFFER_SIZE = MAX_PLAINTEXT_FRAGMENT_LENGTH
	private static final int TLS12_CID_PADDING = 0;
	private static final long CLIENT_HELLO_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(60);
	private static final boolean MDC_SUPPORT;
	protected final DtlsConnectorConfig config;
	private final ResumptionSupportingConnectionStore connectionStore;
	private final Long autoResumptionTimeoutMillis;
	private final int thresholdHandshakesWithoutVerifiedPeer;
	private final AtomicInteger pendingHandshakesWithoutVerifiedPeer = new AtomicInteger();
	protected final DtlsHealth health;
	private final boolean serverOnly;
	private final String defaultHandshakeMode;
	private final int useExtendedWindowFilter;
	private final boolean useFilter;
	private final boolean useCidUpdateAddressOnNewerRecordFilter;
	private final AtomicInteger pendingOutboundMessagesCountdown = new AtomicInteger();
	private final List<Thread> receiverThreads = new LinkedList<Thread>();
	protected final ConnectionIdGenerator connectionIdGenerator;
	private final ProtocolVersion protocolVersionForHelloVerifyRequests;
	private ScheduledFuture<?> statusLogger;
	private InetSocketAddress lastBindAddress;
	private Integer maximumTransmissionUnit;
	private int ipv4Mtu = DEFAULT_IPV4_MTU;
	private int ipv6Mtu = DEFAULT_IPV6_MTU;
	protected int inboundDatagramBufferSize = MAX_DATAGRAM_BUFFER_SIZE;
	private CookieGenerator cookieGenerator = new CookieGenerator();
	private Object alertHandlerLock= new Object();
	private volatile DatagramSocket socket;
	protected ScheduledExecutorService timer;
	private AtomicBoolean running = new AtomicBoolean(false);
	private volatile EndpointContextMatcher endpointContextMatcher;
	private volatile RawDataChannel messageHandler;
	private AlertHandler alertHandler;
	private SessionListener sessionListener;
	private ConnectionExecutionListener connectionExecutionListener;
	private ExecutorService executorService;
	private boolean hasInternalExecutor;
	public void send(final RawData message) {
		if (message == null) {
			throw new NullPointerException("Message must not be null");
		}
		if (health != null) {
			health.sendingRecord(false);
		}
		if (message.isMulticast()) {
			DROP_LOGGER.warn("DTLSConnector drops {} outgoing bytes to multicast {}:{}", message.getSize(), message.getAddress(), message.getPort());
			message.onError(new MulticastNotSupportedException("DTLS doesn't support multicast!"));
			if (health != null) {
				health.sendingRecord(true);
			}
			return;
		}
		if (message.getInetSocketAddress().getPort() == 0) {
			String destination = StringUtil.toString(message.getInetSocketAddress());
			DROP_LOGGER.warn("DTLSConnector drops {} outgoing bytes to [{}] without destination-port",
					message.getSize(), destination);
			message.onError(new IOException("CoAPs message to " + destination + " dropped, destination port 0!"));
			return;
		}
		final Connection connection;
		RuntimeException error = null;

		if (!running.get()) {
			connection = null;
			error = new IllegalStateException("connector must be started before sending messages is possible");
		} else if (message.getSize() > MAX_PLAINTEXT_FRAGMENT_LENGTH) {
			connection = null;
			error = new IllegalArgumentException(
					"Message data must not exceed " + MAX_PLAINTEXT_FRAGMENT_LENGTH + " bytes");
		} else {
			boolean create = !serverOnly;
			if (create) {
				create = !getEffectiveHandshakeMode(message).equals(DtlsEndpointContext.HANDSHAKE_MODE_NONE);
			}
			connection = getConnection(message.getInetSocketAddress(), null, create);
			if (connection == null) {
				if (create) {
					error = new IllegalStateException("connection store is exhausted!");
				} else {
					if (serverOnly) {
						message.onError(new EndpointUnconnectedException("server only, connection missing!"));
					} else {
						message.onError(new EndpointUnconnectedException("connection missing!"));
					}
					DROP_LOGGER.debug("DTLSConnector drops {} outgoing bytes to {}:{}, connection missing!", message.getSize(), message.getAddress(), message.getPort());
					if (health != null) {
						health.sendingRecord(true);
					}
					return;
				}
			}
		}
		if (error != null) {
			DROP_LOGGER.debug("DTLSConnector drops {} outgoing bytes to {}:{}, {}!", message.getSize(),
					message.getAddress(), message.getPort(), error.getMessage());
			message.onError(error);
			if (health != null) {
				health.sendingRecord(true);
			}
			throw error;
		}

		final long now =ClockUtil.nanoRealtime();
		if (pendingOutboundMessagesCountdown.decrementAndGet() >= 0) {
			try {
				SerialExecutor executor = connection.getExecutor();
				if (executor == null) {
					throw new NullPointerException("missing executor for connection! " + connection.getPeerAddress());
				}
				executor.execute(new Runnable() {

					@Override
					public void run() {
						try {
							if (running.get()) {
								sendMessage(now, message, connection);
							} else {
								DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, connector not running!", message.getSize(), message.getAddress(), message.getPort());
								message.onError(new InterruptedIOException("Connector is not running."));
								if (health != null) {
									health.sendingRecord(true);
								}
							}
						} catch (Exception e) {
							if (running.get()) {
								LOGGER.warn("Exception thrown by executor thread [{}]",
										Thread.currentThread().getName(), e);
							}
							DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, {}", message.getSize(), message.getAddress(), message.getPort(), e.getMessage());
							if (health != null) {
								health.sendingRecord(true);
							}
							message.onError(e);
						} finally {
							pendingOutboundMessagesCountdown.incrementAndGet();
						}
					}
				});
			} catch (RejectedExecutionException e) {
				LOGGER.debug("Execution rejected while sending application record [peer: {}]",
						message.getInetSocketAddress(), e);
				DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, {}", message.getSize(), message.getAddress(), message.getPort(), e.getMessage());
				message.onError(new InterruptedIOException("Connector is not running."));
				if (health != null) {
					health.sendingRecord(true);
				}
			}
		} else {
			pendingOutboundMessagesCountdown.incrementAndGet();
			DROP_LOGGER.warn("Outbound message overflow! Dropping outbound message to peer [{}]",
					message.getInetSocketAddress());
			message.onError(new IllegalStateException("Outbound message overflow!"));
			if (health != null) {
				health.sendingRecord(true);
			}
		}
	}
}