public class SerialExecutor extends AbstractExecutorService {
	private static final Logger LOGGER = LoggerFactory.getLogger(SerialExecutor.class);
	private final Executor executor;
	private final AtomicReference<Thread> owner = new AtomicReference<Thread>();
	private final AtomicReference<ExecutionListener> listener = new AtomicReference<ExecutionListener>();
	private final BlockingQueue<Runnable> tasks = new LinkedBlockingQueue<>();
	private final ReentrantLock lock = new ReentrantLock();
	private final Condition terminated = lock.newCondition();
	private Runnable currentlyExecutedJob;
	private boolean shutdown;
	private final void scheduleNextJob() {
		lock.lock();
		try {
			currentlyExecutedJob = tasks.poll();
			if (currentlyExecutedJob != null) {
				final Runnable command = currentlyExecutedJob;
				executor.execute(new Runnable() {

					@Override
					public void run() {
						try {
							try {
								setOwner();
								ExecutionListener current = listener.get();
								try {
									if (current != null) {
										current.beforeExecution();
									}
									command.run();
								} catch (Throwable t) {
									LOGGER.error("unexpected error occurred:", t);
								} finally {
									try {
										if (current != null) {
											current.afterExecution();
										}
									} catch (Throwable t) {
										LOGGER.error("unexpected error occurred:", t);
									}
									clearOwner();
								}
							} finally {
								scheduleNextJob();
							}
						} catch (RejectedExecutionException ex) {
							LOGGER.debug("shutdown?", ex);
						}
					}
				});
			} else if (shutdown) {
				terminated.signalAll();
			}
		} finally {
			lock.unlock();
		}
	}
}