TEST_F(ZlibDecompressorImplTest, CompressAndDecompress) {
  Buffer::OwnedImpl buffer;
  Buffer::OwnedImpl accumulation_buffer;
  Buffer::OwnedImpl empty_buffer;

  Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl compressor;
  compressor.init(
      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionLevel::Standard,
      Extensions::Compression::Gzip::Compressor::ZlibCompressorImpl::CompressionStrategy::Standard,
      gzip_window_bits, memory_level);

  std::string original_text{};
  for (uint64_t i = 0; i < 20; ++i) {
    TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);
    original_text.append(buffer.toString());
    compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);
    accumulation_buffer.add(buffer);
    drainBuffer(buffer);
  }

  ASSERT_EQ(0, buffer.length());

  compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);
  ASSERT_GE(10, buffer.length());

  accumulation_buffer.add(buffer);

  drainBuffer(buffer);
  ASSERT_EQ(0, buffer.length());

  Stats::IsolatedStoreImpl stats_store{};
  ZlibDecompressorImpl decompressor{stats_store, "test."};
  decompressor.init(gzip_window_bits);

  decompressor.decompress(accumulation_buffer, buffer);
  std::string decompressed_text{buffer.toString()};

  // Check decompressor's internal state isn't broken.
  drainBuffer(buffer);
  ASSERT_EQ(0, buffer.length());
  decompressor.decompress(empty_buffer, buffer);
  ASSERT_EQ(0, buffer.length());

  ASSERT_EQ(compressor.checksum(), decompressor.checksum());
  ASSERT_EQ(original_text.length(), decompressed_text.length());
  EXPECT_EQ(original_text, decompressed_text);
  ASSERT_EQ(0, decompressor.decompression_error_);
}