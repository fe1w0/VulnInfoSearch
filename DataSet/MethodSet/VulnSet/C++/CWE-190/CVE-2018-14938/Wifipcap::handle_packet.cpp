void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,
                             const struct pcap_pkthdr *header, const u_char * packet) 
{
    /* Record start time if we don't have it */
    if (startTime == TIME_NONE) {
	startTime = header->ts;
	lastPrintTime = header->ts;
    }
    /* Print stats if necessary */
    if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {
	if (verbose) {
	    int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;
	    int days  = hours/24;
	    int left  = hours%24;
	    fprintf(stderr, "wifipcap: %2d days %2d hours, %10" PRId64 " pkts\n", 
		    days, left, packetsProcessed);
	}
	lastPrintTime = header->ts;
    }
    packetsProcessed++;

    /* Create the packet object and call the appropriate callbacks */
    WifiPacket pkt(cbs,header_type,header,packet);

    /* Notify callback */
    cbs->PacketBegin(pkt, packet, header->caplen, header->len);
    //int frameLen = header->caplen;
    switch(header_type) {
    case DLT_PRISM_HEADER:
        pkt.handle_prism(packet,header->caplen);
        break;
    case DLT_IEEE802_11_RADIO:
        pkt.handle_radiotap(packet,header->caplen);
        break;
    case DLT_IEEE802_11:
        pkt.handle_80211(packet,header->caplen);
        break;
    case DLT_EN10MB:
        pkt.handle_ether(packet,header->caplen);
        break;
    default:
#if 0
	// try handling it as default IP assuming framing is ethernet 
	// (this is for testing)
        pkt.handle_ip(packet,header->caplen);
#endif
        break;
    }
    cbs->PacketEnd(pkt);
}