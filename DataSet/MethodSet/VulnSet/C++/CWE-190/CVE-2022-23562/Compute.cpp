  void Compute(OpKernelContext* context)  {
    const Tensor& start_in = context->input(0);
    const Tensor& limit_in = context->input(1);
    const Tensor& delta_in = context->input(2);
    // TODO(rmlarsen): Disallow legacy use of length-1 vectors as scalars.
    OP_REQUIRES(context,
                TensorShapeUtils::IsScalar(start_in.shape()) ||
                    (TensorShapeUtils::IsVector(start_in.shape()) &&
                     start_in.shape().dim_size(0) == 1),
                errors::InvalidArgument("start must be a scalar, not shape ",
                                        start_in.shape().DebugString()));
    OP_REQUIRES(context,
                TensorShapeUtils::IsScalar(limit_in.shape()) ||
                    (TensorShapeUtils::IsVector(limit_in.shape()) &&
                     limit_in.shape().dim_size(0) == 1),
                errors::InvalidArgument("limit must be a scalar, not shape ",
                                        limit_in.shape().DebugString()));
    OP_REQUIRES(context,
                TensorShapeUtils::IsScalar(delta_in.shape()) ||
                    (TensorShapeUtils::IsVector(delta_in.shape()) &&
                     delta_in.shape().dim_size(0) == 1),
                errors::InvalidArgument("delta must be a scalar, not shape ",
                                        delta_in.shape().DebugString()));
    const T start = start_in.scalar<T>()();
    const T limit = limit_in.scalar<T>()();
    const T delta = delta_in.scalar<T>()();
    OP_REQUIRES(context, delta != 0,
                errors::InvalidArgument("Requires delta != 0: ", delta));
    if (delta > 0) {
      OP_REQUIRES(
          context, start <= limit,
          errors::InvalidArgument(
              "Requires start <= limit when delta > 0: ", start, "/", limit));
    } else {
      OP_REQUIRES(
          context, start >= limit,
          errors::InvalidArgument(
              "Requires start >= limit when delta < 0: ", start, "/", limit));
    }
    int64_t size = 0;
    if (std::is_integral<T>::value) {
      size = static_cast<int64_t>(
          (std::abs(limit - start) + std::abs(delta) - 1) / std::abs(delta));
    } else {
      size = static_cast<int64_t>(std::ceil(std::abs((limit - start) / delta)));
    }
    TensorShape shape;
    OP_REQUIRES_OK(context, shape.AddDimWithStatus(size));
    Tensor* out = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(0, shape, &out));
    if (size == 0) return;
    auto flat = out->flat<T>();
    functor::RangeFunctor<Device, T>()(context, size, start, delta, flat);
  }