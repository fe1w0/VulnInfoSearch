'\n        Classifies candidate periods as sentence breaks, yielding a dict for\n        each that may be used to understand why the decision was made.\n\n        See format_debug_decision() to help make this output readable.\n        '
for match in self._lang_vars.period_context_re().finditer(text):
    decision_text = match.group() + match.group('after_tok')
    tokens = self._tokenize_words(decision_text)
    tokens = list(self._annotate_first_pass(tokens))
    while tokens and (not tokens[0].tok.endswith(self._lang_vars.sent_end_chars)):
        tokens.pop(0)
    yield {'period_index': match.end() - 1, 'text': decision_text, 'type1': tokens[0].type, 'type2': tokens[1].type, 'type1_in_abbrs': bool(tokens[0].abbr), 'type1_is_initial': bool(tokens[0].is_initial), 'type2_is_sent_starter': tokens[1].type_no_sentperiod in self._params.sent_starters, 'type2_ortho_heuristic': self._ortho_heuristic(tokens[1]), 'type2_ortho_contexts': set(self._params._debug_ortho_context(tokens[1].type_no_sentperiod)), 'collocation': (tokens[0].type_no_sentperiod, tokens[1].type_no_sentperiod) in self._params.collocations, 'reason': self._second_pass_annotation(tokens[0], tokens[1]) or REASON_DEFAULT_DECISION, 'break_decision': tokens[0].sentbreak}