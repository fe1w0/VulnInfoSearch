def _run_git(self, git_path, args):
    output = err = exit_status = None
    if not git_path:
        git_path = self._find_working_git()
        if git_path:
            self._git_path = git_path
        else:
            if app.VERSION_NOTIFY:
                log.warning(u"No git specified, can't use git commands")
                app.NEWEST_VERSION_STRING = ERROR_MESSAGE
            exit_status = 1
            return (output, err, exit_status)
    app.NEWEST_VERSION_STRING = None
    cmd = git_path + ' ' + args
    try:
        log.debug(u'Executing {cmd} with your shell in {dir}', {'cmd': cmd, 'dir': app.PROG_DIR})
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True, cwd=app.PROG_DIR)
        (output, err) = p.communicate()
        exit_status = p.returncode
        if isinstance(output, (bytes, bytearray)):
            output = output.decode('utf-8')
        if output:
            output = output.strip()
    except OSError:
        log.info(u"Command {cmd} didn't work", {'cmd': cmd})
        exit_status = 1
    if exit_status == 0:
        log.debug(u'{cmd} : returned successful', {'cmd': cmd})
    elif exit_status == 1:
        if output:
            if 'stash' in output:
                log.warning(u"Enable 'git reset' in settings or stash your changes in local files")
            else:
                log.warning(u'{cmd} returned : {output}', {'cmd': cmd, 'output': output})
        else:
            log.warning(u'{cmd} returned no data', {'cmd': cmd})
    elif exit_status == 128:
        log.warning('{cmd} returned ({status}) : {output}', {'cmd': cmd, 'status': exit_status, 'output': output})
    elif exit_status == 129:
        if 'unknown option' in output and 'set-upstream-to' in output:
            log.info("Can't set upstream to origin/{0} because you're running an old version of git.\nPlease upgrade your git installation to its latest version.", app.BRANCH)
        else:
            log.warning('{cmd} returned ({status}) : {output}', {'cmd': cmd, 'status': exit_status, 'output': output})
    else:
        log.warning(u'{cmd} returned : {output}. Treat as error for now', {'cmd': cmd, 'output': output})
        exit_status = 1
    return (output, err, exit_status)