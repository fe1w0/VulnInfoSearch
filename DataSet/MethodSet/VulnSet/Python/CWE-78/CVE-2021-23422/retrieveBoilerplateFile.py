if group is None and doc.md.group is not None:
    group = doc.md.group.lower()
if status is None:
    if doc.md.status is not None:
        status = doc.md.status
    elif doc.md.rawStatus is not None:
        status = doc.md.rawStatus
(megaGroup, status) = splitStatus(status)
searchLocally = doc.md.localBoilerplate[name]

def boilerplatePath(*segs):
    return scriptPath('boilerplate', *segs)
statusFile = f'{name}-{status}.include'
genericFile = f'{name}.include'
sources = []
if searchLocally:
    sources.append(doc.inputSource.relative(statusFile))
    sources.append(doc.inputSource.relative(genericFile))
else:
    for f in (statusFile, genericFile):
        if doc.inputSource.cheaplyExists(f):
            warn(('Found {0} next to the specification without a matching\n' + 'Local Boilerplate: {1} yes\n' + "in the metadata. This include won't be found when building via a URL.").format(f, name))
            sources.append(doc.inputSource.relative(f))
if group:
    sources.append(InputSource(boilerplatePath(group, statusFile)))
    sources.append(InputSource(boilerplatePath(group, genericFile)))
if megaGroup:
    sources.append(InputSource(boilerplatePath(megaGroup, statusFile)))
    sources.append(InputSource(boilerplatePath(megaGroup, genericFile)))
sources.append(InputSource(boilerplatePath(statusFile)))
sources.append(InputSource(boilerplatePath(genericFile)))
doc.recordDependencies(*sources)
for source in sources:
    if source is not None:
        try:
            return source.read().content
        except OSError:
            pass
else:
    if error:
        die("Couldn't find an appropriate include file for the {0} inclusion, given group='{1}' and status='{2}'.", name, group, status)
    return ''