static cmark_node *check_open_blocks(cmark_parser *parser, cmark_chunk *input,
                                     bool *all_matched) {
  bool should_continue = true;
  *all_matched = false;
  cmark_node *container = parser->root;
  cmark_node_type cont_type;
  cmark_parser tmp_parser; // Only used for its open_block_counts and total_open_blocks fields.
  memcpy(tmp_parser.open_block_counts, parser->open_block_counts, sizeof(parser->open_block_counts));
  tmp_parser.total_open_blocks = parser->total_open_blocks;

  assert(check_open_block_counts(parser));

  while (S_last_child_is_open(container)) {
    decr_open_block_count(&tmp_parser, S_type(container));
    container = container->last_child;
    cont_type = S_type(container);

    S_find_first_nonspace(parser, input);

    if (container->extension) {
      if (!parse_extension_block(parser, container, input))
        goto done;
      continue;
    }

    // This block of code is a workaround for the quadratic performance
    // issue described here (issue 2):
    //
    // https://github.com/github/cmark-gfm/security/advisories/GHSA-66g8-4hjf-77xh
    //
    // If the current line is empty then we might be able to skip directly
    // to the end of the list of open blocks. To determine whether this is
    // possible, we have been maintaining a count of the number of
    // different types of open blocks. The main criterium is that every
    // remaining block, except the last element of the list, is a LIST or
    // ITEM. The code below checks the conditions, and if they're ok, skips
    // forward to parser->current.
    if (parser->blank && parser->indent == 0) {  // Current line is empty
      // Make sure that parser->current doesn't point to a closed block.
      if (parser->current->flags & CMARK_NODE__OPEN_BLOCK) {
        if (parser->current->flags & CMARK_NODE__OPEN) {
          const size_t n_list = read_open_block_count(&tmp_parser, CMARK_NODE_LIST);
          const size_t n_item = read_open_block_count(&tmp_parser, CMARK_NODE_ITEM);
          // At most one block can be something other than a LIST or ITEM.
          if (n_list + n_item + 1 >= tmp_parser.total_open_blocks) {
            // Check that parser->current is suitable for jumping to.
            switch (S_type(parser->current)) {
            case CMARK_NODE_LIST:
            case CMARK_NODE_ITEM:
              if (n_list + n_item != tmp_parser.total_open_blocks) {
                if (parser->current->last_child == NULL) {
                  // There's another node type somewhere in the middle of
                  // the list, so don't attempt the optimization.
                  break;
                }
              }
              // fall through
            case CMARK_NODE_CODE_BLOCK:
            case CMARK_NODE_PARAGRAPH:
            case CMARK_NODE_HTML_BLOCK:
              // Jump to parser->current
              container = parser->current;
              cont_type = S_type(container);
              break;
            default:
              break;
            }
          }
        }
      }
    }

    switch (cont_type) {
    case CMARK_NODE_BLOCK_QUOTE:
      if (!parse_block_quote_prefix(parser, input))
        goto done;
      break;
    case CMARK_NODE_ITEM:
      if (!parse_node_item_prefix(parser, input, container))
        goto done;
      break;
    case CMARK_NODE_CODE_BLOCK:
      if (!parse_code_block_prefix(parser, input, container, &should_continue))
        goto done;
      break;
    case CMARK_NODE_HEADING:
      // a heading can never contain more than one line
      goto done;
    case CMARK_NODE_HTML_BLOCK:
      if (!parse_html_block_prefix(parser, container))
        goto done;
      break;
    case CMARK_NODE_PARAGRAPH:
      if (parser->blank)
        goto done;
      break;
		case CMARK_NODE_FOOTNOTE_DEFINITION:
			if (!parse_footnote_definition_block_prefix(parser, input, container))
				goto done;
			break;
    default:
      break;
    }
  }

  *all_matched = true;

done:
  if (!*all_matched) {
    container = container->parent; // back up to last matching node
  }

  if (!should_continue) {
    container = NULL;
  }

  return container;
}