    char_u *
regtilde(char_u *source, int magic)
{
    char_u	*newsub = source;
    char_u	*p;

    for (p = newsub; *p; ++p)
    {
	if ((*p == '~' && magic) || (*p == '\\' && *(p + 1) == '~' && !magic))
	{
	    if (reg_prev_sub != NULL)
	    {
		// length = len(newsub) - 1 + len(prev_sub) + 1
		// Avoid making the text longer than MAXCOL, it will cause
		// trouble at some point.
		size_t	prevsublen = STRLEN(reg_prev_sub);
		size_t  newsublen = STRLEN(newsub);
		if (prevsublen > MAXCOL || newsublen > MAXCOL
					    || newsublen + prevsublen > MAXCOL)
		{
		    emsg(_(e_resulting_text_too_long));
		    break;
		}

		char_u *tmpsub = alloc(newsublen + prevsublen);
		if (tmpsub != NULL)
		{
		    // copy prefix
		    size_t prefixlen = p - newsub;	// not including ~
		    mch_memmove(tmpsub, newsub, prefixlen);
		    // interpret tilde
		    mch_memmove(tmpsub + prefixlen, reg_prev_sub,
							       prevsublen);
		    // copy postfix
		    if (!magic)
			++p;			// back off backslash
		    STRCPY(tmpsub + prefixlen + prevsublen, p + 1);

		    if (newsub != source)	// allocated newsub before
			vim_free(newsub);
		    newsub = tmpsub;
		    p = newsub + prefixlen + prevsublen;
		}
	    }
	    else if (magic)
		STRMOVE(p, p + 1);	// remove '~'
	    else
		STRMOVE(p, p + 2);	// remove '\~'
	    --p;
	}
	else
	{
	    if (*p == '\\' && p[1])		// skip escaped characters
		++p;
	    if (has_mbyte)
		p += (*mb_ptr2len)(p) - 1;
	}
    }

    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,
    // because recursive calls may make the returned string invalid.
    vim_free(reg_prev_sub);
    reg_prev_sub = vim_strsave(newsub);

    return newsub;
}