int decomp_add_rrdesc(js_string *desc) {
    int rtype, place, counter, fieldnum, subfieldnum;
    unsigned char c;
    rrdesc *new, *point;

    /* Sanity checks */
    if(js_has_sanity(desc) != JS_SUCCESS)
        return JS_ERROR;
    js_set_encode(desc,JS_US_ASCII); /* So js_atoi works */

    /* Determine where to place this record in the hash */
    if((new = js_alloc(1,sizeof(rrdesc))) == 0) {
        return JS_ERROR;
        }

    /* Set up the description.  This is a format where the description
       of each section of the RR is converted in to a single number */
    if((new->description = js_alloc(MAX_RR_SECTIONS,1)) == 0) {
        js_dealloc(new);
        return JS_ERROR;
        }
    /* Clear out the new->description array */
    for(counter = 0; counter < MAX_RR_SECTIONS - 1; counter++) {
        new->description[counter] = 0;
        }

    /* Initialize the "tocompress" field to uninitialized; this is
       a positive number under 127 because some versions of GCC on
       some architectures consider 'char' without 'unsigned' an
       unsigned value. */
    new->tocompress = 79;

    /* Now, parse the string describing the message */
    fieldnum = subfieldnum = 1;
    rtype = -1;
    for(counter = 0; counter < desc->unit_count ; counter++) {
        c = *(desc->string + counter);
        if(fieldnum == 1) { /* RR number field */
            if(subfieldnum == 1) /* Before first colon */ {
                if(c == ':') {
                    subfieldnum++;
                    }
                }
            else if(subfieldnum == 2) /* Number immediately after colon */ {
                if(rtype == -1) {
                    rtype = js_atoi(desc,counter);
                    if(rtype <= 0 || rtype > 65535) {
                        js_dealloc(new->description);
                        js_dealloc(new);
                        return JS_ERROR;
                        }
                    new->rr_num = rtype;
                    }
                if(c == '|') {
                    subfieldnum = 1;
                    fieldnum = 2;
                    }
                }
            }
        else if(fieldnum == 2) { /* RR name field */
            if(c == '|') {
                subfieldnum = 1;
                fieldnum = 3;
                }
            }
        else if(fieldnum == 3) { /* The description of the RRs themselves */
            /* Bounds check */
            if(subfieldnum > MAX_RR_SECTIONS - 2) {
                js_dealloc(new->description);
                js_dealloc(new);
                return JS_ERROR;
                }
            /* Process the RR subfield; this code only supports one-character
               labels (quick and dirty; but I want to get 1.0 out the door)
             */
            if(new->description[subfieldnum - 1] == 0) {
                if(c >= '1' && c <= '9') {
                    new->description[subfieldnum - 1] = c - '0';
                    }
                else if(c == 'D') {
                    new->description[subfieldnum - 1] = RRSUB_DLABEL;
                    }
                else if(c == 'T') {
                    new->description[subfieldnum - 1] = RRSUB_TEXT;
                    }
                else if(c == 'V') {
                    new->description[subfieldnum - 1] = RRSUB_VARIABLE;
                    }
                else { /* Unknown type */
                    js_dealloc(new->description);
                    js_dealloc(new);
                    return JS_ERROR;
                    }
                }
             else if(c != ';' && c != '|') { /* Multi-char description */
                 js_dealloc(new->description);
                 js_dealloc(new);
                 return JS_ERROR;
                 }
             else if(c == ';') {
                 /* Variable ('V') *must* be the last subfield */
                 if(new->description[subfieldnum - 1] == RRSUB_VARIABLE) {
                    js_dealloc(new->description);
                    js_dealloc(new);
                    return JS_ERROR;
                    }
                 subfieldnum++;
                 }
             else if(c == '|') {
                 subfieldnum = 1;
                 fieldnum = 4;
                 }
             else { /* Should never happen */
                 js_dealloc(new->description);
                 js_dealloc(new);
                 return JS_ERROR;
                 }
             }
         else if(fieldnum == 4) { /* Whether we can compress this field
                                     or not; currently ignored */
             if(c == 'C' && new->tocompress == 79) {
                new->tocompress = 1;
                }
             else if(c == 'N' && new->tocompress == 79) {
                new->tocompress = 0;
                }
             else if(c == '|' && new->tocompress != 79) {
                subfieldnum = 1;
                fieldnum = 5;
                }
             else { /* Invalid for field num */
                js_dealloc(new->description);
                js_dealloc(new);
                return -4;
                }
             }
         else if(fieldnum == 5) { /* Description of field; currently
                                     ignored */
             /* XXX: We really want something here which makes sure we
                     have at least three subfields and considers a colon
                     the start of a new RR */
             break;
             }
         }

     /* Now that the new field is set up, add the new element to the
        hash of rr descriptions */

     place = rtype % RR_HASH_SIZE;
     if(rr_formats == 0) {
        js_dealloc(new->description);
        js_dealloc(new);
        return JS_ERROR;
        }
     point = rr_formats[place];
     if(point == 0) {
         rr_formats[place] = new;
         }
     else {
         while(point->next != 0)
             point = point->next;
         point->next = new;
         }

     new->next = 0;

     /* OK, we're done (finally!) */
     return JS_SUCCESS;
     }

/* decomp_init

   Initialize the decompression code; set up the RRs, and set the
   log_level global variable in the decompression code.

   Input

   The desired log_level for all of the decompression code

   Output

   JS_SUCCESS on success
   JS_ERROR on error

   Global variables affected

   rr_formats (indirectly via decomp_add_rrdesc)
   log_level

 */

int decomp_init(int alog_level) {
    js_string *temp; /* Used for storing the indivual RR descriptions */
    int counter;

    /* Create the string */
    if((temp = js_create(256,1)) == 0) {
        return JS_ERROR;
        }

    /* Add the records to the big hash */
    decomp_init_rrdesc();
    for(counter = 0 ; counter < RR_COUNT ; counter++) {
        if(js_qstr2js(temp,rr_descs[counter]) != JS_SUCCESS) {
            js_destroy(temp);
            return JS_ERROR;
            }
        if(decomp_add_rrdesc(temp) != JS_SUCCESS) {
            js_destroy(temp);
            return JS_ERROR;
            }
        }

    /* Set the log level */
    dlog_level = alog_level;

    js_destroy(temp);
    return JS_SUCCESS;

    }

/* decomp_get_rddesc

   Given the rtype (rr_num) (e.g. The resource record number where 1 is A,
   etc.), give them a pointer to a null-terminated string which
   contains the compiled rr description

   Input

   The number RR they wish

   Output

   A pointer to the compiled rr description.  0 if there was any
   problem getting that

   Global variables used

   The "rr_formats" hash

   Notes

   This string can not be changed; if it is bad things can happen

 */

char *decomp_get_rrdesc(int rr_num) {
    rrdesc *point;

    if(rr_formats == 0)
        return 0;

    point = rr_formats[rr_num % RR_HASH_SIZE];
    if(point == 0)
        return 0;

    while(point->rr_num != rr_num) {
        point = point->next;
        if(point == 0)
            return 0;
        }

    return point->description;

    }

/* decomp_get_rddata

   Get the rddata from the compressed string, decompressing any dlabels
   as needed, and append the data to the uncompressed string.

   Input

   compressed: The compressed string
   out: A js_string object to place the output in
   compressed_offset: Where in the string to look (0 is the top of the
     string, 1 is the second byte of the string, etc.)
   type: The type of resource record (1 for A, 2 for NS, etc.)
   rdlength: The rdlength this resource record should have

   Output

   JS_ERROR on error, JS_SUCCESS if there was no problem processing

 */

int decomp_get_rddata(js_string *compressed, js_string *out,
                      unsigned int compressed_offset, int type, int rdlength) {

    char *desc;
    int subtype, total, len;

    desc = decomp_get_rrdesc(type);

    if(desc == 0) { /* Unknown RR type */
        if(rdlength == 0) {
            return JS_SUCCESS;
            }
        if(decomp_append_bytes(compressed,out,compressed_offset,
                               rdlength) != JS_SUCCESS) {
            return JS_ERROR;
            }
        else {
            return JS_SUCCESS;
            }
        }
    else {
        subtype = *desc;
        total = 0;
        /* Handle the various types of data we can get in the RR RDDATA */
        while(subtype != 0) {
            /* Fix-length data fields */
            if(subtype > 0 && subtype < 64) {
                if(decomp_append_bytes(compressed,out,
                   compressed_offset,subtype) != JS_SUCCESS) {
                       return JS_ERROR;
                       }
                total += subtype;
                compressed_offset += subtype;
                }
            /* Dlabels (which may be compressed) */
            else if(subtype == RRSUB_DLABEL) {
                len = decomp_append_dlabel(compressed,out,
                        compressed_offset);
                if(len == JS_ERROR) {
                    return JS_ERROR;
                    }
                total += len;
                compressed_offset += len;
                }
            /* Text data fields */
            else if(subtype == RRSUB_TEXT) {
                /* Data abstraction violation */
                len = *(compressed->string + compressed_offset);
                len += 1; /* To account for the one byte which
                             describes the length */
                if(len < 0 || len > 256) {
                    return JS_ERROR;
                    }
                if(decomp_append_bytes(compressed,out,
                                       compressed_offset,len) !=
                   JS_SUCCESS) {
                    return JS_ERROR;
                    }
                total += len;
                compressed_offset += len;
                }
            /* Variable length data (length determined by rdlength) */
            else if(subtype == RRSUB_VARIABLE) {
                len = rdlength - total;
                if(len <= 0) {
                    break;
                    }
                if(decomp_append_bytes(compressed,out,
                                       compressed_offset,len) != JS_SUCCESS) {
                    return JS_ERROR;
                    }
                total += len;
                compressed_offset += len;
                }
            else { /* Should never happen */
                return JS_ERROR;
                }
            desc++;
            /* RRSUB_VARIABLE must be the last subtype */
            if(subtype != RRSUB_VARIABLE)
                subtype = *desc;
            else
                subtype = 0; /* break the loop */
            }
        /* Sanity check; make sure that rdlength panned out */
        if(rdlength != total) {
            return JS_ERROR;
            }
        }

    /* The record's rddata was sucessfully decompressed */
    return JS_SUCCESS;
    }

/* decomp_decompress_packet

   Uncompressed a query (or reply) compressed with the RFC1035 compression
   alogrithm (see RFC1035  4.1.4)

   Input

   Pointer to compressed DNS packet
   Pointer to uncompressed DNS packet

   Output

   JS_ERROR on error
   JS_SUCCESS on success

 */

int decomp_decompress_packet(js_string *compressed, js_string *uncompressed) {

    int answers; /* Number of answers */
    int type, rdlength; /* As per RFC1035  3.2.1 */
    int offset,length;
    js_string *rddata;

    /* Sanity checks */

    if(js_has_sanity(compressed) == JS_ERROR)
        return JS_ERROR;
    if(js_has_sanity(uncompressed) == JS_ERROR)
        return JS_ERROR;
    if(compressed->unit_size != 1 || uncompressed->unit_size != 1)
        return JS_ERROR;
    if(uncompressed->unit_count != 0)
        return JS_ERROR;

    /* Create the string for storing the rddata */
#ifndef AUTHONLY
    if((rddata = js_create(512,1)) == 0) {
        return JS_ERROR;
        }
#else
    if((rddata = js_create(4512,1)) == 0) {
        return JS_ERROR;
        }
#endif
    /* Read the header */

    answers = decomp_get_header(compressed,uncompressed);
    if(answers == -2) { /* No questions and no answers */
        js_destroy(rddata);
        return JS_SUCCESS;
        }
    else if(answers == JS_ERROR) {
        js_destroy(rddata);
        return JS_ERROR;
        }

    /* Process the question (if applicable) */
    if(answers <= -3) {
        answers = -2 - answers; /* So -3 becomes 1 answer, -4 becomes
                                   2 answers, etc. */
        length = 0;
        }
    else {
        length = decomp_get_question(compressed,uncompressed);
        if(length < 1) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        }

    offset = 12 + length;

    /* Process the answers */
    while(answers > 0) {
        length = decomp_append_dlabel(compressed,uncompressed,offset);
        if(length < 1) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += length;
        type = decomp_get_type_etc(compressed,uncompressed,offset);
        if(type == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += 8;
        rdlength = decomp_get_rdlength(compressed,offset);
        if(rdlength == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += 2;
        /* Hack: zero out the rddata string */
        rddata->unit_count = 0;
        if(decomp_get_rddata(compressed,rddata,offset,type,rdlength)
           != JS_SUCCESS) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        /* Add the decompressed rdlength */
        if(js_adduint16(uncompressed,rddata->unit_count) == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        /* And the decompressed rddata */
        if(js_append(rddata,uncompressed) == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += rdlength; /* The compressed rdlength */
        answers--;
        }

    js_destroy(rddata);
    return JS_SUCCESS;
    }

/* decompress_data

   This and the decomp_init function are the only functions which should
   be visible to other code; the only "public methods" so to speak

   Input

   compressed string, uncompressed string

   Output

   JS_ERROR on error, JS_SUCCESS on success

 */

int decompress_data(js_string *compressed, js_string *uncompressed) {
    /* zero-out the uncompressed string */
    uncompressed->unit_count = 0;

    if(dlog_level >= 5) {
       printf("About to decompress packet: ");
       show_esc_stdout(compressed);
       printf("\n");
       }

    if(dlog_level == -1) { /* Uninitialized, return error */
        return JS_ERROR;
        }
    else {
        return decomp_decompress_packet(compressed,uncompressed);
        }

    /* We should never end up here */
    return JS_ERROR;
    }

/* Since the compression code needs to use the same rr_formats database,
   this bit of code exports the rr_formats hash so that the compression
   code can use it */

rrdesc **decomp_export_rrformats() {
    return rr_formats;
    }
