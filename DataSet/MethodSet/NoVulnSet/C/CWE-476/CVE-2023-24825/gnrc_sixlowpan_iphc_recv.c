void gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *sixlo, void *rbuf_ptr,
                              unsigned page)
{
    assert(sixlo != NULL);
    gnrc_pktsnip_t *ipv6, *netif;
    gnrc_netif_t *iface;
    ipv6_hdr_t *ipv6_hdr;
    uint8_t *iphc_hdr = sixlo->data;
    size_t payload_offset;
    size_t uncomp_hdr_len = sizeof(ipv6_hdr_t);
    gnrc_sixlowpan_frag_rb_t *rbuf = rbuf_ptr;
#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB
    gnrc_sixlowpan_frag_vrb_t *vrbe = NULL;
#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */

    if (sixlo->size < 2U) {
        DEBUG("6lo iphc: IPHC header truncated\n");
        if (rbuf != NULL) {
            gnrc_sixlowpan_frag_rb_remove(rbuf);
        }
        gnrc_pktbuf_release(sixlo);
        return;
    }
    if (rbuf != NULL) {
        ipv6 = rbuf->pkt;
        assert(ipv6 != NULL);
        if ((ipv6->size < sizeof(ipv6_hdr_t)) &&
            (gnrc_pktbuf_realloc_data(ipv6, sizeof(ipv6_hdr_t)) != 0)) {
            DEBUG("6lo iphc: no space to decompress IPHC\n");
            _recv_error_release(sixlo, ipv6, rbuf);
            return;
        }
    }
    else {
        ipv6 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),
                               GNRC_NETTYPE_IPV6);
        if (ipv6 == NULL) {
            gnrc_pktbuf_release(sixlo);
            return;
        }
    }

    assert(ipv6->size >= sizeof(ipv6_hdr_t));

    netif = gnrc_pktsnip_search_type(sixlo, GNRC_NETTYPE_NETIF);
    assert(netif != NULL);
    iface = gnrc_netif_hdr_get_netif(netif->data);
    payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,
                                       ipv6->data);
    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {
        /* unable to parse IPHC header or malicious packet */
        DEBUG("6lo iphc: malformed IPHC header\n");
        _recv_error_release(sixlo, ipv6, rbuf);
        return;
    }
#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC
    if (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {
        bool nhc_header = true;
        ipv6_hdr = ipv6->data;
        size_t prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);

        while (nhc_header) {
            switch (iphc_hdr[payload_offset] & NHC_ID_MASK) {
                case NHC_IPV6_EXT_ID:
                case NHC_IPV6_EXT_ID_ALT:
                    payload_offset = _iphc_nhc_ipv6_decode(sixlo,
                                                           payload_offset,
                                                           rbuf,
                                                           &prev_nh_offset,
                                                           ipv6,
                                                           &uncomp_hdr_len);
                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {
                        /* unable to parse IPHC header or malicious packet */
                        DEBUG("6lo iphc: malformed IPHC NHC IPv6 header\n");
                        _recv_error_release(sixlo, ipv6, rbuf);
                        return;
                    }
                    /* prev_nh_offset is set to 0 if next header is not
                     * compressed (== NH flag in compression header not set) */
                    nhc_header = (prev_nh_offset > 0);
                    break;
                case NHC_UDP_ID: {
                    payload_offset = _iphc_nhc_udp_decode(sixlo,
                                                          payload_offset,
                                                          rbuf,
                                                          prev_nh_offset,
                                                          ipv6,
                                                          &uncomp_hdr_len);
                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {
                        /* unable to parse IPHC header or malicious packet */
                        DEBUG("6lo iphc: malformed IPHC NHC IPv6 header\n");
                        _recv_error_release(sixlo, ipv6, rbuf);
                        return;
                    }
                    /* no NHC after UDP header */
                    nhc_header = false;
                    break;
                }
                default:
                    nhc_header = false;
                    break;
            }
        }
    }
#endif
    uint16_t payload_len;
    if (rbuf != NULL) {
        /* for a fragmented datagram we know the overall length already */
        if (_is_rfrag(sixlo)) {
            DEBUG("6lo iphc: calculating payload length for SFR\n");
            DEBUG(" - rbuf->super.datagram_size: %u\n",
                  rbuf->super.datagram_size);
            DEBUG(" - payload_offset: %u\n", (unsigned)payload_offset);
            DEBUG(" - uncomp_hdr_len: %u\n", (unsigned)uncomp_hdr_len);
            /* set IPv6 header payload length field to the length of whatever is
             * left after removing the 6LoWPAN header and adding uncompressed
             * headers */
            payload_len = (rbuf->super.datagram_size - payload_offset) +
                          (uncomp_hdr_len - sizeof(ipv6_hdr_t));
            DEBUG("   => %u\n", payload_len);
            /* adapt datagram size for uncompressed datagram */
#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR
            /* guard required because SFR-specific field of vrbe is accessed */
            rbuf->offset_diff += (uncomp_hdr_len - payload_offset);
            rbuf->super.datagram_size += rbuf->offset_diff;
#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */
        }
        else {
            /* for a fragmented datagram we know the overall length already */
            payload_len = (uint16_t)(rbuf->super.datagram_size - sizeof(ipv6_hdr_t));
        }
#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB
        /* re-assign IPv6 header in case realloc changed the address */
        ipv6_hdr = ipv6->data;
        DEBUG("6lo iphc: VRB present, trying to create entry for dst %s\n",
              ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));
        /* only create virtual reassembly buffer entry from IPv6 destination if
         * the current first fragment is the only received fragment in the
         * reassembly buffer so far and the hop-limit is larger than 1
         */
        if ((rbuf->super.current_size <= sixlo->size) && (ipv6_hdr->hl > 1U) &&
            /* and there is enough slack for changing compression */
            (rbuf->super.current_size <= iface->sixlo.max_frag_size) &&
            (vrbe = gnrc_sixlowpan_frag_vrb_from_route(&rbuf->super, iface,
                                                       ipv6))) {
            /* add netif header to `ipv6` so its flags can be used when
             * forwarding the fragment */
            sixlo = gnrc_pkt_delete(sixlo, netif);
            ipv6 = gnrc_pkt_append(ipv6, netif);
            /* provide space to copy remaining payload */
            if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + sixlo->size -
                                         payload_offset) != 0) {
                DEBUG("6lo iphc: no space left to copy payload\n");
                gnrc_sixlowpan_frag_vrb_rm(vrbe);
                _recv_error_release(sixlo, ipv6, rbuf);
                return;
            }
        }
        /* reallocate to copy complete payload */
        else if (gnrc_pktbuf_realloc_data(ipv6, rbuf->super.datagram_size) != 0) {
            DEBUG("6lo iphc: no space left to reassemble payload\n");
            _recv_error_release(sixlo, ipv6, rbuf);
            return;
        }
#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */
    }
    else {
        /* set IPv6 header payload length field to the length of whatever is left
         * after removing the 6LoWPAN header and adding uncompressed headers */
        payload_len = (sixlo->size + uncomp_hdr_len -
                       payload_offset - sizeof(ipv6_hdr_t));
    }
    if (rbuf == NULL) {
        /* (rbuf == NULL) => forwarding is not affected by this */
        if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + payload_len) != 0) {
            DEBUG("6lo iphc: no space left to copy payload\n");
            _recv_error_release(sixlo, ipv6, rbuf);
            return;
        }
    }
    else {
        if (ipv6->size < (uncomp_hdr_len + (sixlo->size - payload_offset))) {
            DEBUG("6lo iphc: not enough space to copy payload.\n");
            DEBUG("6lo iphc: potentially malicious datagram size received.\n");
            _recv_error_release(sixlo, ipv6, rbuf);
            return;
        }
    }

    /* re-assign IPv6 header in case realloc changed the address */
    ipv6_hdr = ipv6->data;
    ipv6_hdr->len = byteorder_htons(payload_len);
    if (sixlo->size > payload_offset) {
        memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,
               ((uint8_t *)sixlo->data) + payload_offset,
               sixlo->size - payload_offset);
    }
    if (rbuf != NULL) {
        rbuf->super.current_size += (uncomp_hdr_len - payload_offset);
#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB
        if (vrbe != NULL) {
            int res = -1;
            DEBUG("6lo iphc: found route, trying to forward\n");
            ipv6_hdr->hl--;
            vrbe->super.current_size = rbuf->super.current_size;
            if ((ipv6 = _encode_frag_for_forwarding(ipv6, vrbe))) {
#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR
                /* guard required because SFR-specific field of vrbe is
                 * accessed */
                if (_is_rfrag(sixlo)) {
                    vrbe->in_netif = iface;
                    /* calculate offset difference due to compression */
                    vrbe->offset_diff = ((int)gnrc_pkt_len(ipv6->next)) -
                                        sixlo->size;
                }
#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */
                if ((res = _forward_frag(ipv6, sixlo->next, vrbe, page)) == 0) {
                    DEBUG("6lo iphc: successfully recompressed and forwarded "
                          "1st fragment\n");
                    /* empty list, as it should be in VRB now */
                    rbuf->super.ints = NULL;
                }
            }
            if ((ipv6 == NULL) || (res < 0)) {
                /* TODO: There is a potential to fall-back to classic reassembly
                 * when ipv6 != NULL. However, since `ipv6` was reversed in
                 * `_encode_frag_for_forwarding`, that step needs to be reversed
                 * or a version of the old ipv6 needs to be held in the buffer.
                 * For now, just drop the packet all together in an error case
                 */
                gnrc_sixlowpan_frag_vrb_rm(vrbe);
            }
            gnrc_pktbuf_release(sixlo);
            /* don't remove `rbuf->pkt` (aka ipv6) as it was forwarded */
            gnrc_sixlowpan_frag_rb_remove(rbuf);
            return;
        }
        DEBUG("6lo iphc: no route found, reassemble datagram normally\n");
#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */
    }
    else {
        sixlo = gnrc_pkt_delete(sixlo, netif);
        ipv6 = gnrc_pkt_append(ipv6, netif);
        gnrc_sixlowpan_dispatch_recv(ipv6, NULL, page);
    }
    gnrc_pktbuf_release(sixlo);
    return;
}