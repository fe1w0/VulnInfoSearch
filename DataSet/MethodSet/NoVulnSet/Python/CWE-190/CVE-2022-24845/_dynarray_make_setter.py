assert isinstance(src.typ, DArrayType)
assert isinstance(dst.typ, DArrayType)
if src.value == '~empty':
    return IRnode.from_list(STORE(dst, 0))
if src.value == 'multi':
    ret = ['seq']
    store_length = STORE(dst, len(src.args))
    ann = None
    if src.annotation is not None:
        ann = f'len({src.annotation})'
    store_length = IRnode.from_list(store_length, annotation=ann)
    ret.append(store_length)
    n_items = len(src.args)
    for i in range(n_items):
        k = IRnode.from_list(i, typ='uint256')
        dst_i = get_element_ptr(dst, k, array_bounds_check=False)
        src_i = get_element_ptr(src, k, array_bounds_check=False)
        ret.append(make_setter(dst_i, src_i))
    return ret
with src.cache_when_complex('darray_src') as (b1, src):
    should_loop = src.encoding == Encoding.ABI and src.typ.subtype.abi_type.is_dynamic()
    should_loop |= src.typ.subtype.abi_type.is_dynamic()
    should_loop |= needs_clamp(src.typ.subtype, src.encoding)
    with get_dyn_array_count(src).cache_when_complex('darray_count') as (b2, count):
        ret = ['seq']
        ret.append(STORE(dst, count))
        if should_loop:
            i = IRnode.from_list(_freshname('copy_darray_ix'), typ='uint256')
            loop_body = make_setter(get_element_ptr(dst, i, array_bounds_check=False), get_element_ptr(src, i, array_bounds_check=False))
            loop_body.annotation = f'{dst}[i] = {src}[i]'
            ret.append(['repeat', i, 0, count, src.typ.count, loop_body])
        else:
            element_size = src.typ.subtype.memory_bytes_required
            n_bytes = _mul(count, element_size)
            max_bytes = src.typ.count * element_size
            src_ = dynarray_data_ptr(src)
            dst_ = dynarray_data_ptr(dst)
            ret.append(copy_bytes(dst_, src_, n_bytes, max_bytes))
        return b1.resolve(b2.resolve(ret))