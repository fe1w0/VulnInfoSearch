external_contract = '\n@external\ndef returns_Bytes3() -> Bytes[3]:\n    return b"123"\n    '
should_not_compile = '\nimport BadJSONInterface as BadJSONInterface\n@external\ndef foo(x: BadJSONInterface) -> Bytes[2]:\n    return slice(x.returns_Bytes3(), 0, 2)\n    '
code = '\nimport BadJSONInterface as BadJSONInterface\n\nfoo: BadJSONInterface\n\n@external\ndef __init__(addr: BadJSONInterface):\n    self.foo = addr\n\n\n@external\ndef test_fail1() -> Bytes[2]:\n    # should compile, but raise runtime exception\n    return self.foo.returns_Bytes3()\n\n@external\ndef test_fail2() -> Bytes[2]:\n    # should compile, but raise runtime exception\n    x: Bytes[2] = self.foo.returns_Bytes3()\n    return x\n\n@external\ndef test_fail3() -> Bytes[3]:\n    # should revert - returns_Bytes3 is inferred to have return type Bytes[2]\n    # (because test_fail3 comes after test_fail1)\n    return self.foo.returns_Bytes3()\n\n    '
bad_c = get_contract(external_contract)
bad_c_interface = {'BadJSONInterface': {'type': 'json', 'code': compile_code(external_contract, ['abi'])['abi']}}
assert_compile_failed(lambda : get_contract(should_not_compile, interface_codes=bad_c_interface), ArgumentException)
c = get_contract(code, bad_c.address, interface_codes=bad_c_interface)
assert bad_c.returns_Bytes3() == b'123'
assert_tx_failed(lambda : c.test_fail1())
assert_tx_failed(lambda : c.test_fail2())
assert_tx_failed(lambda : c.test_fail3())