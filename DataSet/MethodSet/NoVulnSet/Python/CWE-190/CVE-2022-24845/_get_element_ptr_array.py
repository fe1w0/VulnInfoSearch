assert isinstance(parent.typ, ArrayLike)
if not is_integer_type(key.typ):
    raise TypeCheckFailure(f'{key.typ} used as array index')
subtype = parent.typ.subtype
if parent.value == '~empty':
    if array_bounds_check:
        raise TypeCheckFailure('indexing into zero array not allowed')
    return IRnode.from_list('~empty', subtype)
if parent.value == 'multi':
    assert isinstance(key.value, int)
    return parent.args[key.value]
ix = unwrap_location(key)
if array_bounds_check:
    clamp_op = 'uclamplt'
    is_darray = isinstance(parent.typ, DArrayType)
    bound = get_dyn_array_count(parent) if is_darray else parent.typ.count
    ix = IRnode.from_list([clamp_op, ix, bound], typ=ix.typ)
if parent.encoding == Encoding.ABI:
    if parent.location == STORAGE:
        raise CompilerPanic('storage variables should not be abi encoded')
    member_abi_t = subtype.abi_type
    ofst = _mul(ix, member_abi_t.embedded_static_size())
    return _getelemptr_abi_helper(parent, subtype, ofst)
if parent.location.word_addressable:
    element_size = subtype.storage_size_in_words
elif parent.location.byte_addressable:
    element_size = subtype.memory_bytes_required
else:
    raise CompilerPanic('unreachable')
ofst = _mul(ix, element_size)
if has_length_word(parent.typ):
    data_ptr = add_ofst(parent, parent.location.word_scale * DYNAMIC_ARRAY_OVERHEAD)
else:
    data_ptr = parent
return IRnode.from_list(add_ofst(data_ptr, ofst), typ=subtype, location=parent.location)