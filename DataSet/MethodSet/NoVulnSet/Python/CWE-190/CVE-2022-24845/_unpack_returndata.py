ast_return_t = expr.func._metadata['type'].return_type
if ast_return_t is None:
    return (['pass'], 0, 0)
return_t = new_type_to_old_type(ast_return_t)
check_assign(dummy_node_for_type(return_t), dummy_node_for_type(contract_sig.return_type))
return_t = calculate_type_for_external_return(return_t)
abi_return_t = return_t.abi_type
min_return_size = abi_return_t.min_size()
max_return_size = abi_return_t.size_bound()
assert 0 < min_return_size <= max_return_size
ret_ofst = buf
ret_len = max_return_size
ret = []
if not skip_contract_check:
    ret += [['assert', ['ge', 'returndatasize', min_return_size]]]
encoding = Encoding.ABI
buf = IRnode.from_list(buf, typ=return_t, location=MEMORY, encoding=encoding, annotation=f'{expr.node_source_code} returndata buffer')
assert isinstance(return_t, TupleType)
if needs_clamp(return_t, encoding):
    buf2 = IRnode.from_list(context.new_internal_variable(return_t), typ=return_t, location=MEMORY)
    ret.append(make_setter(buf2, buf))
    ret.append(buf2)
else:
    ret.append(buf)
return (ret, ret_ofst, ret_len)