def _setup(self):
    """Setup this image object based on current tags"""
    if 48129 in self.tag_v2:
        raise OSError('Windows Media Photo files not yet supported')
    self._compression = COMPRESSION_INFO[self.tag_v2.get(COMPRESSION, 1)]
    self._planar_configuration = self.tag_v2.get(PLANAR_CONFIGURATION, 1)
    photo = self.tag_v2.get(PHOTOMETRIC_INTERPRETATION, 0)
    if self._compression == 'tiff_jpeg':
        photo = 6
    fillorder = self.tag_v2.get(FILLORDER, 1)
    logger.debug('*** Summary ***')
    logger.debug(f'- compression: {self._compression}')
    logger.debug(f'- photometric_interpretation: {photo}')
    logger.debug(f'- planar_configuration: {self._planar_configuration}')
    logger.debug(f'- fill_order: {fillorder}')
    logger.debug(f'- YCbCr subsampling: {self.tag.get(YCBCRSUBSAMPLING)}')
    xsize = int(self.tag_v2.get(IMAGEWIDTH))
    ysize = int(self.tag_v2.get(IMAGELENGTH))
    self._size = (xsize, ysize)
    logger.debug(f'- size: {self.size}')
    sample_format = self.tag_v2.get(SAMPLEFORMAT, (1,))
    if len(sample_format) > 1 and max(sample_format) == min(sample_format) == 1:
        sample_format = (1,)
    bps_tuple = self.tag_v2.get(BITSPERSAMPLE, (1,))
    extra_tuple = self.tag_v2.get(EXTRASAMPLES, ())
    if photo in (2, 6, 8):
        bps_count = 3
    elif photo == 5:
        bps_count = 4
    else:
        bps_count = 1
    bps_count += len(extra_tuple)
    bps_actual_count = len(bps_tuple)
    samples_per_pixel = self.tag_v2.get(SAMPLESPERPIXEL, 3 if self._compression == 'tiff_jpeg' and photo in (2, 6) else 1)
    if samples_per_pixel > MAX_SAMPLESPERPIXEL:
        logger.error('More samples per pixel than can be decoded: %s', samples_per_pixel)
        raise SyntaxError('Invalid value for samples per pixel')
    if samples_per_pixel < bps_actual_count:
        bps_tuple = bps_tuple[:samples_per_pixel]
    elif samples_per_pixel > bps_actual_count and bps_actual_count == 1:
        bps_tuple = bps_tuple * samples_per_pixel
    if len(bps_tuple) != samples_per_pixel:
        raise SyntaxError('unknown data organization')
    key = (self.tag_v2.prefix, photo, sample_format, fillorder, bps_tuple, extra_tuple)
    logger.debug(f'format key: {key}')
    try:
        (self.mode, rawmode) = OPEN_INFO[key]
    except KeyError as e:
        logger.debug('- unsupported format')
        raise SyntaxError('unknown pixel mode') from e
    logger.debug(f'- raw mode: {rawmode}')
    logger.debug(f'- pil mode: {self.mode}')
    self.info['compression'] = self._compression
    xres = self.tag_v2.get(X_RESOLUTION, 1)
    yres = self.tag_v2.get(Y_RESOLUTION, 1)
    if xres and yres:
        resunit = self.tag_v2.get(RESOLUTION_UNIT)
        if resunit == 2:
            self.info['dpi'] = (xres, yres)
        elif resunit == 3:
            self.info['dpi'] = (xres * 2.54, yres * 2.54)
        elif resunit is None:
            self.info['dpi'] = (xres, yres)
            self.info['resolution'] = (xres, yres)
        else:
            self.info['resolution'] = (xres, yres)
    x = y = layer = 0
    self.tile = []
    self.use_load_libtiff = READ_LIBTIFF or self._compression != 'raw'
    if self.use_load_libtiff:
        if fillorder == 2:
            key = key[:3] + (1,) + key[4:]
            logger.debug(f'format key: {key}')
            (self.mode, rawmode) = OPEN_INFO[key]
        if rawmode == 'I;16':
            rawmode = 'I;16N'
        if ';16B' in rawmode:
            rawmode = rawmode.replace(';16B', ';16N')
        if ';16L' in rawmode:
            rawmode = rawmode.replace(';16L', ';16N')
        if photo == 6 and self._compression == 'jpeg' and (self._planar_configuration == 1):
            rawmode = 'RGB'
        a = (rawmode, self._compression, False, self.tag_v2.offset)
        self.tile.append(('libtiff', (0, 0, xsize, ysize), 0, a))
    elif STRIPOFFSETS in self.tag_v2 or TILEOFFSETS in self.tag_v2:
        if STRIPOFFSETS in self.tag_v2:
            offsets = self.tag_v2[STRIPOFFSETS]
            h = self.tag_v2.get(ROWSPERSTRIP, ysize)
            w = self.size[0]
        else:
            offsets = self.tag_v2[TILEOFFSETS]
            w = self.tag_v2.get(TILEWIDTH)
            h = self.tag_v2.get(TILELENGTH)
        for offset in offsets:
            if x + w > xsize:
                stride = w * sum(bps_tuple) / 8
            else:
                stride = 0
            tile_rawmode = rawmode
            if self._planar_configuration == 2:
                tile_rawmode = rawmode[layer]
                stride /= bps_count
            a = (tile_rawmode, int(stride), 1)
            self.tile.append((self._compression, (x, y, min(x + w, xsize), min(y + h, ysize)), offset, a))
            x = x + w
            if x >= self.size[0]:
                (x, y) = (0, y + h)
                if y >= self.size[1]:
                    x = y = 0
                    layer += 1
    else:
        logger.debug('- unsupported data organization')
        raise SyntaxError('unknown data organization')
    if ICCPROFILE in self.tag_v2:
        self.info['icc_profile'] = self.tag_v2[ICCPROFILE]
    if self.mode in ['P', 'PA']:
        palette = [o8(b // 256) for b in self.tag_v2[COLORMAP]]
        self.palette = ImagePalette.raw('RGB;L', b''.join(palette))
    self._tile_orientation = self.tag_v2.get(274)