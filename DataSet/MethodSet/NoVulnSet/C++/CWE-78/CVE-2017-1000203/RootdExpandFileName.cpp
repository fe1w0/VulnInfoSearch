Bool_t RootdExpandFileName(const char *fname, char *xname, const int kBufSize)
{
   int n, ier, iter, lx, ncopy;
   char *inp, *out, *x, *t, buff[kBufSize * 4];
   const char *b, *c, *e;
   const char *p;

   iter = 0;
   xname[0] = 0;
   inp = buff + kBufSize;
   out = inp + kBufSize;
   inp[-1] = ' ';
   inp[0] = 0;
   out[-1] = ' ';
   c = fname + strspn(fname, " \t\f\r");
   // VP  if (isalnum(c[0])) { strcpy(inp, WorkingDirectory()); strcat(inp, "/"); } // add $cwd

   strncat(inp, c, kBufSize - strlen(inp) - 1);

again:
   iter++;
   c = inp;
   ier = 0;
   x = out;
   x[0] = 0;

   p = 0;
   e = 0;
   if (c[0] == '~' && c[1] == '/') { // ~/ case
      std::string hd = HomeDirectory(0);
      p = hd.c_str();
      e = c + 1;
      if (p) { // we have smth to copy
         strlcpy(x, p, kBufSize);
         x += strlen(p);
         c = e;
      } else {
         ++ier;
         ++c;
      }
   } else if (c[0] == '~' && c[1] != '/') { // ~user case
      n = strcspn(c + 1, "/ ");
      buff[0] = 0;
      strncat(buff, c + 1, n);
      std::string hd = HomeDirectory(buff);
      e = c + 1 + n;
      if (!hd.empty()) { // we have smth to copy
         p = hd.c_str();
         strlcpy(x, p, kBufSize);
         x += strlen(p);
         c = e;
      } else {
         x++ [0] = c[0];
         //++ier;
         ++c;
      }
   }

   for (; c[0]; c++) {

      p = 0;
      e = 0;

      if (c[0] == '.' && c[1] == '/' && c[-1] == ' ') { // $cwd
         std::string wd = WorkingDirectory();
         strlcpy(buff, wd.c_str(), kBufSize);
         p = buff;
         e = c + 1;
      }
      if (p) { // we have smth to copy */
         strlcpy(x, p, kBufSize);
         x += strlen(p);
         c = e - 1;
         continue;
      }

      if (c[0] != '$') { // not $, simple copy
         x++ [0] = c[0];
      } else { // we have a $
         b = c + 1;
         if (c[1] == '(') b++;
         if (c[1] == '{') b++;
         if (b[0] == '$')
            e = b + 1;
         else
            for (e = b; isalnum(e[0]) || e[0] == '_'; e++)
               ;
         buff[0] = 0;
         strncat(buff, b, e - b);
         p = getenv(buff);
         if (!p) { // too bad, try UPPER case
            for (t = buff; (t[0] = toupper(t[0])); t++)
               ;
            p = getenv(buff);
         }
         if (!p) { // too bad, try Lower case
            for (t = buff; (t[0] = tolower(t[0])); t++)
               ;
            p = getenv(buff);
         }
         if (!p && !strcmp(buff, "cwd")) { // it is $cwd
            std::string wd = WorkingDirectory();
            strlcpy(buff, wd.c_str(), kBufSize);
            p = buff;
         }
         if (!p && !strcmp(buff, "$")) { // it is $$ (replace by getpid())
            snprintf(buff, kBufSize * 4, "%d", (int)getpid());
            p = buff;
         }
         if (!p) { // too bad, nothing can help
            ier++;
            x++ [0] = c[0];
         } else { // It is OK, copy result
            int lp = strlen(p);
            if (lp >= kBufSize) {
               // make sure lx will be >= kBufSize (see below)
               strlcpy(x, p, kBufSize);
               x += kBufSize;
               break;
            }
            strcpy(x, p);
            x += lp;
            c = (b == c + 1) ? e - 1 : e;
         }
      }
   }

   x[0] = 0;
   lx = x - out;
   if (ier && iter < 3) {
      strlcpy(inp, out, kBufSize);
      goto again;
   }
   ncopy = (lx >= kBufSize) ? kBufSize - 1 : lx;
   xname[0] = 0;
   strncat(xname, out, ncopy);

   if (ier || ncopy != lx) {
      Error(ErrFatal, kErrFatal, "RootdExpandFileName: fatal error:\n\t input: %s\n\t output: %s", fname, xname);
      return true;
   }

   return false;
}