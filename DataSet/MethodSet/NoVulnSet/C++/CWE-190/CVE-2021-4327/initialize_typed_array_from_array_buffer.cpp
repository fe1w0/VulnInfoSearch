static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)
{
    // 22.2.5.1.3 InitializeTypedArrayFromArrayBuffer, https://tc39.es/ecma262/#sec-initializetypedarrayfromarraybuffer

    auto& vm = global_object.vm();
    auto element_size = typed_array.element_size();
    auto offset = byte_offset.to_index(global_object);
    if (vm.exception())
        return;
    if (offset % element_size != 0) {
        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);
        return;
    }
    size_t new_length { 0 };
    if (!length.is_undefined()) {
        new_length = length.to_index(global_object);
        if (vm.exception())
            return;
    }
    // FIXME: 8. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
    auto buffer_byte_length = array_buffer.byte_length();
    Checked<size_t> new_byte_length;
    if (length.is_undefined()) {
        if (buffer_byte_length % element_size != 0) {
            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);
            return;
        }
        if (offset > buffer_byte_length) {
            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);
            return;
        }
        new_byte_length = buffer_byte_length;
        new_byte_length -= offset;
    } else {
        new_byte_length = new_length;
        new_byte_length *= element_size;

        Checked<size_t> new_byte_end = new_byte_length;
        new_byte_end += offset;

        if (new_byte_end.has_overflow()) {
            vm.throw_exception<RangeError>(global_object, ErrorType::InvalidLength, "typed array");
            return;
        }

        if (new_byte_end.value() > buffer_byte_length) {
            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, new_byte_end.value(), buffer_byte_length);
            return;
        }
    }
    if (new_byte_length.has_overflow()) {
        vm.throw_exception<RangeError>(global_object, ErrorType::InvalidLength, "typed array");
        return;
    }

    typed_array.set_viewed_array_buffer(&array_buffer);
    typed_array.set_byte_length(new_byte_length.value());
    typed_array.set_byte_offset(offset);
    typed_array.set_array_length(new_byte_length.value() / element_size);
}