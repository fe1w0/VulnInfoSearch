public class DTLSConnector implements Connector, RecordLayer {
	public static final String KEY_TLS_SERVER_HOST_NAME = "TLS_SERVER_HOST_NAME";
	public static final Logger LOGGER = LoggerFactory.getLogger(DTLSConnector.class);
	public static final Logger DROP_LOGGER = LoggerFactory.getLogger(LOGGER.getName() + ".drops");
	public static final int MAX_PLAINTEXT_FRAGMENT_LENGTH = 16384; // max. DTLSPlaintext.length (2^14 bytes)
	public static final int MAX_CIPHERTEXT_EXPANSION = CipherSuite.getOverallMaxCiphertextExpansion();
	public static final int MAX_DATAGRAM_BUFFER_SIZE = MAX_PLAINTEXT_FRAGMENT_LENGTH
	public static final int TLS12_CID_PADDING = 0;
	public static final long CLIENT_HELLO_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(60);
	public static final boolean MDC_SUPPORT;
	public final DtlsConnectorConfig config;
	public final ResumptionSupportingConnectionStore connectionStore;
	public final Long autoResumptionTimeoutMillis;
	public final int thresholdHandshakesWithoutVerifiedPeer;
	public final AtomicInteger pendingHandshakesWithoutVerifiedPeer = new AtomicInteger();
	public final DtlsHealth health;
	public final boolean serverOnly;
	public final String defaultHandshakeMode;
	public final int useExtendedWindowFilter;
	public final boolean useFilter;
	public final boolean useCidUpdateAddressOnNewerRecordFilter;
	public final AtomicInteger pendingOutboundMessagesCountdown = new AtomicInteger();
	public final List<Thread> receiverThreads = new LinkedList<Thread>();
	public final ConnectionIdGenerator connectionIdGenerator;
	public final ProtocolVersion protocolVersionForHelloVerifyRequests;
	public ScheduledFuture<?> statusLogger;
	public InetSocketAddress lastBindAddress;
	public Integer maximumTransmissionUnit;
	public int ipv4Mtu = DEFAULT_IPV4_MTU;
	public int ipv6Mtu = DEFAULT_IPV6_MTU;
	public int inboundDatagramBufferSize = MAX_DATAGRAM_BUFFER_SIZE;
	public CookieGenerator cookieGenerator = new CookieGenerator();
	public Object alertHandlerLock= new Object();
	public volatile DatagramSocket socket;
	public ScheduledExecutorService timer;
	public AtomicBoolean running = new AtomicBoolean(false);
	public volatile EndpointContextMatcher endpointContextMatcher;
	public volatile RawDataChannel messageHandler;
	public AlertHandler alertHandler;
	public SessionListener sessionListener;
	public ConnectionExecutionListener connectionExecutionListener;
	public ExecutorService executorService;
	public boolean hasInternalExecutor;
	public void stop() {
		ExecutorService shutdownTimer = null;
		ExecutorService shutdown = null;
		List<Runnable> pending = new ArrayList<>();
		synchronized (this) {
			if (running.compareAndSet(true, false)) {
				if (statusLogger != null) {
					statusLogger.cancel(false);
					statusLogger = null;
				}
				LOGGER.info("Stopping DTLS connector on [{}]", lastBindAddress);
				for (Thread t : receiverThreads) {
					t.interrupt();
				}
				if (socket != null) {
					socket.close();
					socket = null;
				}
				maximumTransmissionUnit = null;
				ipv4Mtu = DEFAULT_IPV4_MTU;
				ipv6Mtu = DEFAULT_IPV6_MTU;
				connectionStore.stop(pending);
				if (executorService != timer) {
					pending.addAll(timer.shutdownNow());
					shutdownTimer = timer;
					timer = null;
				}
				if (hasInternalExecutor) {
					pending.addAll(executorService.shutdownNow());
					shutdown = executorService;
					executorService = null;
					hasInternalExecutor = false;
				}
				for (Thread t : receiverThreads) {
					t.interrupt();
					try {
						t.join(500);
					} catch (InterruptedException e) {
					}
				}
				receiverThreads.clear();
			}
		}
		if (shutdownTimer != null) {
			try {
				if (!shutdownTimer.awaitTermination(500, TimeUnit.MILLISECONDS)) {
					LOGGER.warn("Shutdown DTLS connector on [{}] timer not terminated in time!", lastBindAddress);
				}
			} catch (InterruptedException e) {
			}
		}
		if (shutdown != null) {
			try {
				if (!shutdown.awaitTermination(500, TimeUnit.MILLISECONDS)) {
					LOGGER.warn("Shutdown DTLS connector on [{}] executor not terminated in time!", lastBindAddress);
				}
			} catch (InterruptedException e) {
			}
		}
		for (Runnable job : pending) {
			try {
				job.run();
			} catch (Throwable e) {
				LOGGER.warn("Shutdown DTLS connector:", e);
			}
		}
	}
}