public class InMemoryConnectionStore implements ResumptionSupportingConnectionStore, CloseSupportingConnectionStore {
	public static final Logger LOG = LoggerFactory.getLogger(InMemoryConnectionStore.class);
	public static final int DEFAULT_SMALL_EXTRA_CID_LENGTH = 2; // extra cid bytes additionally to required bytes for small capacity.
	public static final int DEFAULT_LARGE_EXTRA_CID_LENGTH = 3; // extra cid bytes additionally to required bytes for large capacity.
	public static final int DEFAULT_CACHE_SIZE = 150000;
	public static final long DEFAULT_EXPIRATION_THRESHOLD = 36 * 60 * 60; // 36h
	public final SessionCache sessionCache;
	public final LeastRecentlyUsedCache<ConnectionId, Connection> connections;
	public final ConcurrentMap<InetSocketAddress, Connection> connectionsByAddress;
	public final ConcurrentMap<SessionId, Connection> connectionsByEstablishedSession;
	public ConnectionListener connectionListener;
	public ConnectionIdGenerator connectionIdGenerator;
	public String tag = "";
	public synchronized boolean remove(final Connection connection, final boolean removeFromSessionCache) {
		boolean removed = connections.remove(connection.getConnectionId(), connection) == connection;
		if (removed) {
			int pending = 0;
			SerialExecutor executor = connection.getExecutor();
			if (executor != null) {
				List<Runnable> pendings = connection.getExecutor().shutdownNow();
				for (Runnable job : pendings) {
					try {
						job.run();
					} catch (Throwable e) {
						LOG.warn("Removing connection:", e);
					}
				}
				pending = pendings.size();
			}
			if (LOG.isTraceEnabled()) {
				LOG.trace("{}connection: remove {} (size {}, left jobs: {})", tag, connection, connections.size(),
						pending, new Throwable("connection removed!"));
			} else if (pending == 0) {
				LOG.debug("{}connection: remove {} (size {})", tag, connection, connections.size());
			} else {
				LOG.debug("{}connection: remove {} (size {}, left jobs: {})", tag, connection, connections.size(),
						pending);
			}
			removeFromEstablishedSessions(connection);
			removeFromAddressConnections(connection);
			if (removeFromSessionCache) {
				removeSessionFromCache(connection);
			}
			ConnectionListener listener = connectionListener;
			if (listener != null) {
				listener.onConnectionRemoved(connection);
			}
		}
		return removed;
	}
}