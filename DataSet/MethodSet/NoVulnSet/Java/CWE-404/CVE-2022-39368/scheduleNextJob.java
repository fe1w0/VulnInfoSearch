public class SerialExecutor extends AbstractExecutorService {
	public static final Logger LOGGER = LoggerFactory.getLogger(SerialExecutor.class);
	public final Executor executor;
	public final AtomicReference<Thread> owner = new AtomicReference<Thread>();
	public final AtomicReference<ExecutionListener> listener = new AtomicReference<ExecutionListener>();
	public final BlockingQueue<Runnable> tasks = new LinkedBlockingQueue<>();
	public final ReentrantLock lock = new ReentrantLock();
	public final Condition terminated = lock.newCondition();
	public Runnable currentlyExecutedJob;
	public boolean shutdown;
	public final void scheduleNextJob() {
		lock.lock();
		try {
			currentlyExecutedJob = tasks.poll();
			if (currentlyExecutedJob != null) {
				final Runnable command = currentlyExecutedJob;
				executor.execute(new Runnable() {

					@Override
					public void run() {
						try {
							setOwner();
							ExecutionListener current = listener.get();
							try {
								if (current != null) {
									current.beforeExecution();
								}
								command.run();
							} catch (Throwable t) {
								LOGGER.error("unexpected error occurred:", t);
							} finally {
								try {
									if (current != null) {
										current.afterExecution();
									}
								} catch (Throwable t) {
									LOGGER.error("unexpected error occurred after execution:", t);
								}
								clearOwner();
							}
						} finally {
							try {
								scheduleNextJob();
							} catch (RejectedExecutionException ex) {
								LOGGER.debug("shutdown?", ex);
							}
						}
					}
				});
			} else if (shutdown) {
				terminated.signalAll();
			}
		} finally {
			lock.unlock();
		}
	}
}