public class DTLSConnector implements Connector, RecordLayer {
	public static final String KEY_TLS_SERVER_HOST_NAME = "TLS_SERVER_HOST_NAME";
	public static final Logger LOGGER = LoggerFactory.getLogger(DTLSConnector.class);
	public static final Logger DROP_LOGGER = LoggerFactory.getLogger(LOGGER.getName() + ".drops");
	public static final int MAX_PLAINTEXT_FRAGMENT_LENGTH = 16384; // max. DTLSPlaintext.length (2^14 bytes)
	public static final int MAX_CIPHERTEXT_EXPANSION = CipherSuite.getOverallMaxCiphertextExpansion();
	public static final int MAX_DATAGRAM_BUFFER_SIZE = MAX_PLAINTEXT_FRAGMENT_LENGTH
	public static final int TLS12_CID_PADDING = 0;
	public static final long CLIENT_HELLO_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(60);
	public static final boolean MDC_SUPPORT;
	public final DtlsConnectorConfig config;
	public final ResumptionSupportingConnectionStore connectionStore;
	public final Long autoResumptionTimeoutMillis;
	public final int thresholdHandshakesWithoutVerifiedPeer;
	public final AtomicInteger pendingHandshakesWithoutVerifiedPeer = new AtomicInteger();
	public final DtlsHealth health;
	public final boolean serverOnly;
	public final String defaultHandshakeMode;
	public final int useExtendedWindowFilter;
	public final boolean useFilter;
	public final boolean useCidUpdateAddressOnNewerRecordFilter;
	public final AtomicInteger pendingOutboundMessagesCountdown = new AtomicInteger();
	public final List<Thread> receiverThreads = new LinkedList<Thread>();
	public final ConnectionIdGenerator connectionIdGenerator;
	public final ProtocolVersion protocolVersionForHelloVerifyRequests;
	public ScheduledFuture<?> statusLogger;
	public InetSocketAddress lastBindAddress;
	public Integer maximumTransmissionUnit;
	public int ipv4Mtu = DEFAULT_IPV4_MTU;
	public int ipv6Mtu = DEFAULT_IPV6_MTU;
	public int inboundDatagramBufferSize = MAX_DATAGRAM_BUFFER_SIZE;
	public CookieGenerator cookieGenerator = new CookieGenerator();
	public Object alertHandlerLock= new Object();
	public volatile DatagramSocket socket;
	public ScheduledExecutorService timer;
	public AtomicBoolean running = new AtomicBoolean(false);
	public volatile EndpointContextMatcher endpointContextMatcher;
	public volatile RawDataChannel messageHandler;
	public AlertHandler alertHandler;
	public SessionListener sessionListener;
	public ConnectionExecutionListener connectionExecutionListener;
	public ExecutorService executorService;
	public boolean hasInternalExecutor;
	public void processNewClientHello(final Record record) {
		InetSocketAddress peerAddress = record.getPeerAddress();
		if (LOGGER.isTraceEnabled()) {
			StringBuilder msg = new StringBuilder("Processing new CLIENT_HELLO from peer [")
					.append(peerAddress).append("]").append(":").append(StringUtil.lineSeparator()).append(record);
			LOGGER.trace(msg.toString());
		}
		try {
			// CLIENT_HELLO with epoch 0 is not encrypted, so use DTLSConnectionState.NULL 
			record.applySession(null);
			DTLSMessage message = record.getFragment();
			if (message instanceof FragmentedHandshakeMessage) {
				LOGGER.debug("Received unsupported fragmented CLIENT_HELLO from peer [{}].", peerAddress);
				discardRecord(record, new DtlsException("Fragmented CLIENT_HELLO is not supported!", peerAddress));
				return;
			}
			final ClientHello clientHello = (ClientHello) message;

			// before starting a new handshake or resuming an established
			// session we need to make sure that the peer is in possession of
			// the IP address indicated in the client hello message
			final AvailableConnections connections = new AvailableConnections();
			if (isClientInControlOfSourceIpAddress(clientHello, record, connections)) {
				boolean verify = false;
				ExecutorService executorService = getExecutorService();
				Connection connection;
				synchronized (connectionStore) {
					connection = connectionStore.get(peerAddress);
					if (connection != null && !connection.isStartedByClientHello(clientHello)) {
						Connection sessionConnection = connections.getConnectionBySessionId();
						if (sessionConnection != null && sessionConnection != connection) {
							// don't overwrite
							verify = true;
						} else {
							if (sessionConnection != null && sessionConnection == connection) {
								connections.setRemoveConnectionBySessionId(true);
							}
							final Handshaker handshaker = connection.getOngoingHandshake();
							if (handshaker != null) {
								DTLSSession establishedSession = connection.getEstablishedSession();
								if (establishedSession == null || handshaker.getSession() != establishedSession) {
									final DtlsException cause = new DtlsException(
											"Received new CLIENT_HELLO from " + StringUtil.toDisplayString(peerAddress),
											peerAddress);
									handshaker.setFailureCause(cause);
									connection.getExecutor().execute(new Runnable() {

										@Override
										public void run() {
											if (running.get()) {
												handshaker.handshakeFailed(cause);
											}
										}
									});
								}
							}
							connection = null;
						}
					}
					if (connection == null) {
						connection = new Connection(peerAddress, new SerialExecutor(executorService));
						connection.setExecutionListener(connectionExecutionListener);
						connection.startByClientHello(clientHello);
						if (!connectionStore.put(connection)) {
							return;
						}
					}
				}
				if (verify) {
					sendHelloVerify(clientHello, record, null);
				} else {
					connections.setConnectionByAddress(connection);
					try {
						connection.getExecutor().execute(new Runnable() {
							@Override
							public void run() {
								if (running.get() && connections.getConnectionByAddress().isExecuting()) {
									processClientHello(clientHello, record, connections);
								}
							}
						});
					} catch (RejectedExecutionException e) {
						// dont't terminate connection on shutdown!
						LOGGER.debug("Execution rejected while processing record [type: {}, peer: {}]",
								record.getType(), peerAddress, e);
					} catch (RuntimeException e) {
						LOGGER.warn("Unexpected error occurred while processing record [type: {}, peer: {}]",
								record.getType(), peerAddress, e);
						terminateConnection(connections.getConnectionByAddress(), e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);
					}
				}
			}
		} catch (HandshakeException e) {
			LOGGER.debug("Processing new CLIENT_HELLO from peer [{}] failed!", record.getPeerAddress(), e);
		} catch (GeneralSecurityException e) {
			DROP_LOGGER.debug("Processing new CLIENT_HELLO from peer [{}] failed!", record.getPeerAddress(), e);
		} catch (RuntimeException e) {
			LOGGER.warn("Processing new CLIENT_HELLO from peer [{}] failed!", record.getPeerAddress(), e);
		}
	}
}