class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {
    public static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);
    public static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(
    public static final Argument ARGUMENT_PART_DATA = Argument.of(PartData.class);
    public final Router router;
    public final ExecutorSelector executorSelector;
    public final StaticResourceResolver staticResourceResolver;
    public final ExecutorService ioExecutor;
    public final BeanLocator beanLocator;
    public final NettyHttpServerConfiguration serverConfiguration;
    public final RequestArgumentSatisfier requestArgumentSatisfier;
    public final MediaTypeCodecRegistry mediaTypeCodecRegistry;
    public final NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry;
    public Flowable<? extends MutableHttpResponse<?>> filterPublisher(
            AtomicReference<HttpRequest<?>> requestReference,
            Publisher<MutableHttpResponse<?>> routePublisher,
            ExecutorService executor,
            boolean skipOncePerRequest) {
        Publisher<? extends io.micronaut.http.MutableHttpResponse<?>> finalPublisher;
        List<HttpFilter> filters = new ArrayList<>(router.findFilters(requestReference.get()));
        if (skipOncePerRequest) {
            filters.removeIf(filter -> filter instanceof OncePerRequestHttpServerFilter);
        }
        if (!filters.isEmpty()) {
            // make the action executor the last filter in the chain
            filters.add((HttpServerFilter) (req, chain) -> routePublisher);

            AtomicInteger integer = new AtomicInteger();
            int len = filters.size();
            ServerFilterChain filterChain = new ServerFilterChain() {
                @SuppressWarnings("unchecked")
                @Override
                public Publisher<MutableHttpResponse<?>> proceed(io.micronaut.http.HttpRequest<?> request) {
                    int pos = integer.incrementAndGet();
                    if (pos > len) {
                        throw new IllegalStateException("The FilterChain.proceed(..) method should be invoked exactly once per filter execution. The method has instead been invoked multiple times by an erroneous filter definition.");
                    }
                    HttpFilter httpFilter = filters.get(pos);
                    return (Publisher<MutableHttpResponse<?>>) httpFilter.doFilter(requestReference.getAndSet(request), this);
                }
            };
            HttpFilter httpFilter = filters.get(0);
            Publisher<? extends HttpResponse<?>> resultingPublisher = httpFilter.doFilter(requestReference.get(), filterChain);
            finalPublisher = (Publisher<? extends MutableHttpResponse<?>>) resultingPublisher;
        } else {
            finalPublisher = routePublisher;
        }

        // Handle the scheduler to subscribe on
        if (finalPublisher instanceof Flowable) {
            return ((Flowable<MutableHttpResponse<?>>) finalPublisher)
                    .subscribeOn(Schedulers.from(executor));
        } else {
            return Flowable.fromPublisher(finalPublisher)
                    .subscribeOn(Schedulers.from(executor));
        }
    }
}