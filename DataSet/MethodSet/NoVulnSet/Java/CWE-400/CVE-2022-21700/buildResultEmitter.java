class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {
    private static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);
    private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(
    private static final Argument ARGUMENT_PART_DATA = Argument.of(PartData.class);
    private final Router router;
    private final ExecutorSelector executorSelector;
    private final StaticResourceResolver staticResourceResolver;
    private final ExecutorService ioExecutor;
    private final BeanLocator beanLocator;
    private final NettyHttpServerConfiguration serverConfiguration;
    private final RequestArgumentSatisfier requestArgumentSatisfier;
    private final MediaTypeCodecRegistry mediaTypeCodecRegistry;
    private final NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry;
    public Flowable<?> buildResultEmitter(
            ChannelHandlerContext context, RouteMatch<?> finalRoute,
            AtomicReference<HttpRequest<?>> requestReference,
            boolean isReactiveReturnType,
            boolean isSingleResult) {
        Flowable<?> resultEmitter;
        if (isReactiveReturnType) {
            // if the return type is reactive, execute the action and obtain the Observable
            try {
                if (isSingleResult) {
                    // for a single result we are fine as is
                    resultEmitter = Flowable.defer(() -> {
                        final RouteMatch<?> routeMatch = !finalRoute.isExecutable() ? requestArgumentSatisfier.fulfillArgumentRequirements(finalRoute, requestReference.get(), true) : finalRoute;
                        Object result = routeMatch.execute();
                        return Publishers.convertPublisher(result, Publisher.class);
                    });
                } else {
                    // for a streaming response we wrap the result on an HttpResponse so that a single result is received
                    // then the result can be streamed chunk by chunk
                    resultEmitter = Flowable.create((emitter) -> {
                        final RouteMatch<?> routeMatch = !finalRoute.isExecutable() ? requestArgumentSatisfier.fulfillArgumentRequirements(finalRoute, requestReference.get(), true) : finalRoute;
                        Object result = routeMatch.execute();
                        MutableHttpResponse<Object> chunkedResponse = HttpResponse.ok(result);
                        chunkedResponse.header(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
                        emitter.onNext(chunkedResponse);
                        emitter.onComplete();
                        // should be no back pressure
                    }, BackpressureStrategy.ERROR);
                }
            } catch (Throwable e) {
                resultEmitter = Flowable.error(new InternalServerException("Error executing route [" + finalRoute + "]: " + e.getMessage(), e));
            }
        } else {
            // for non-reactive results we build flowable that executes the
            // route
            resultEmitter = Flowable.create((emitter) -> {
                HttpRequest<?> httpRequest = requestReference.get();
                RouteMatch<?> routeMatch = finalRoute;
                if (!routeMatch.isExecutable()) {
                    routeMatch = requestArgumentSatisfier.fulfillArgumentRequirements(routeMatch, httpRequest, true);
                }
                Object result;
                try {
                    result = routeMatch.execute();
                } catch (Throwable e) {
                    emitter.onError(e);
                    return;
                }

                if (result instanceof Optional) {
                    result = ((Optional<?>) result).orElse(null);
                }

                if (result == null) {
                    // empty flowable
                    emitter.onComplete();
                } else {
                    // emit the result
                    if (result instanceof Writable) {
                        ByteBuf byteBuf = context.alloc().ioBuffer(128);
                        ByteBufOutputStream outputStream = new ByteBufOutputStream(byteBuf);
                        Writable writable = (Writable) result;
                        writable.writeTo(outputStream, requestReference.get().getCharacterEncoding());
                        emitter.onNext(byteBuf);
                    } else {
                        emitter.onNext(result);
                    }
                    emitter.onComplete();
                }

                // should be no back pressure
            }, BackpressureStrategy.ERROR);
        }
        return resultEmitter;
    }
}