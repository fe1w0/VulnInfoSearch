class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {
    private static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);
    private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(
    private static final Argument ARGUMENT_PART_DATA = Argument.of(PartData.class);
    private final Router router;
    private final ExecutorSelector executorSelector;
    private final StaticResourceResolver staticResourceResolver;
    private final ExecutorService ioExecutor;
    private final BeanLocator beanLocator;
    private final NettyHttpServerConfiguration serverConfiguration;
    private final RequestArgumentSatisfier requestArgumentSatisfier;
    private final MediaTypeCodecRegistry mediaTypeCodecRegistry;
    private final NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry;
    private Subscriber<Object> buildSubscriber(NettyHttpRequest<?> request,
                                               ChannelHandlerContext context,
                                               RouteMatch<?> finalRoute) {
        return new CompletionAwareSubscriber<Object>() {
            Boolean alwaysAddContent = request.getContentType()
                    .map(type -> type.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE))
                    .orElse(false);
            RouteMatch<?> routeMatch = finalRoute;
            AtomicBoolean executed = new AtomicBoolean(false);
            AtomicLong pressureRequested = new AtomicLong(0);
            ConcurrentHashMap<String, UnicastProcessor> subjects = new ConcurrentHashMap<>();
            ConcurrentHashMap<Integer, HttpDataReference> dataReferences = new ConcurrentHashMap<>();
            ConversionService conversionService = ConversionService.SHARED;
            Subscription s;
            LongConsumer onRequest = (num) -> pressureRequested.updateAndGet((p) -> {
                long newVal = p - num;
                if (newVal < 0) {
                    s.request(num - p);
                    return 0;
                } else {
                    return newVal;
                }
            });

            Flowable processFlowable(Flowable flowable, Integer dataKey, boolean controlsFlow) {
                if (controlsFlow) {
                    flowable = flowable.doOnRequest(onRequest);
                }
                return flowable
                        .doAfterTerminate(() -> {
                            if (controlsFlow) {
                                HttpDataReference dataReference = dataReferences.get(dataKey);
                                dataReference.destroy();
                            }
                        });
            }

            @Override
            protected void doOnSubscribe(Subscription subscription) {
                this.s = subscription;
                subscription.request(1);
            }

            @Override
            protected void doOnNext(Object message) {
                boolean executed = this.executed.get();
                if (message instanceof ByteBufHolder) {
                    if (message instanceof HttpData) {
                        HttpData data = (HttpData) message;

                        if (LOG.isTraceEnabled()) {
                            LOG.trace("Received HTTP Data for request [{}]: {}", request, message);
                        }

                        String name = data.getName();
                        Optional<Argument<?>> requiredInput = routeMatch.getRequiredInput(name);

                        if (requiredInput.isPresent()) {
                            Argument<?> argument = requiredInput.get();
                            Supplier<Object> value;
                            boolean isPublisher = Publishers.isConvertibleToPublisher(argument.getType());
                            boolean chunkedProcessing = false;

                            if (isPublisher) {
                                Integer dataKey = System.identityHashCode(data);
                                HttpDataReference dataReference = dataReferences.computeIfAbsent(dataKey, (key) -> {
                                    return new HttpDataReference(data);
                                });
                                Argument typeVariable;

                                if (StreamingFileUpload.class.isAssignableFrom(argument.getType())) {
                                    typeVariable = ARGUMENT_PART_DATA;
                                } else {
                                    typeVariable = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
                                }
                                Class typeVariableType = typeVariable.getType();

                                UnicastProcessor namedSubject = subjects.computeIfAbsent(name, (key) -> UnicastProcessor.create());

                                chunkedProcessing = PartData.class.equals(typeVariableType) ||
                                        Publishers.isConvertibleToPublisher(typeVariableType) ||
                                        ClassUtils.isJavaLangType(typeVariableType);

                                if (Publishers.isConvertibleToPublisher(typeVariableType)) {
                                    boolean streamingFileUpload = StreamingFileUpload.class.isAssignableFrom(typeVariableType);
                                    if (streamingFileUpload) {
                                        typeVariable = ARGUMENT_PART_DATA;
                                    } else {
                                        typeVariable = typeVariable.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
                                    }
                                    dataReference.subject.getAndUpdate(subject -> {
                                        if (subject == null) {
                                            UnicastProcessor childSubject = UnicastProcessor.create();
                                            Flowable flowable = processFlowable(childSubject, dataKey, true);
                                            if (streamingFileUpload && data instanceof FileUpload) {
                                                namedSubject.onNext(new NettyStreamingFileUpload(
                                                        (FileUpload) data,
                                                        serverConfiguration.getMultipart(),
                                                        ioExecutor,
                                                        flowable));
                                            } else {
                                                namedSubject.onNext(flowable);
                                            }

                                            return childSubject;
                                        }
                                        return subject;
                                    });

                                }

                                UnicastProcessor subject = Optional.ofNullable(dataReference.subject.get()).orElse(namedSubject);

                                Object part = data;

                                if (chunkedProcessing) {
                                    HttpDataReference.Component component = dataReference.addComponent((e) -> {
                                        subject.onError(e);
                                        s.cancel();
                                    });
                                    if (component == null) {
                                        return;
                                    }
                                    part = new NettyPartData(dataReference, component);
                                }

                                if (data instanceof FileUpload &&
                                        StreamingFileUpload.class.isAssignableFrom(argument.getType())) {
                                    dataReference.upload.getAndUpdate(upload -> {
                                        if (upload == null) {
                                            return new NettyStreamingFileUpload(
                                                    (FileUpload) data,
                                                    serverConfiguration.getMultipart(),
                                                    ioExecutor,
                                                    processFlowable(subject, dataKey, true));
                                        }
                                        return upload;
                                    });
                                }

                                Optional<?> converted = conversionService.convert(part, typeVariable);

                                converted.ifPresent(subject::onNext);

                                if (data.isCompleted() && chunkedProcessing) {
                                    subject.onComplete();
                                }

                                value = () -> {
                                    StreamingFileUpload upload = dataReference.upload.get();
                                    if (upload != null) {
                                        return upload;
                                    } else {
                                        return processFlowable(namedSubject, dataKey, dataReference.subject.get() == null);
                                    }
                                };

                            } else {
                                if (data instanceof Attribute && !data.isCompleted()) {
                                    request.addContent(data);
                                    s.request(1);
                                    return;
                                } else {
                                    value = () -> {
                                        if (data.refCnt() > 0) {
                                            return data;
                                        } else {
                                            return null;
                                        }
                                    };
                                }
                            }

                            if (!executed) {
                                String argumentName = argument.getName();
                                if (!routeMatch.isSatisfied(argumentName)) {
                                    routeMatch = routeMatch.fulfill(Collections.singletonMap(argumentName, value.get()));
                                }
                                if (isPublisher && chunkedProcessing) {
                                    //accounting for the previous request
                                    pressureRequested.incrementAndGet();
                                }
                                if (routeMatch.isExecutable() || message instanceof LastHttpContent) {
                                    executeRoute();
                                    executed = true;
                                }
                            }

                            if (alwaysAddContent) {
                                request.addContent(data);
                            }

                            if (!executed || !chunkedProcessing) {
                                s.request(1);
                            }

                        } else {
                            request.addContent(data);
                            s.request(1);
                        }
                    } else {
                        request.addContent((ByteBufHolder) message);
                        s.request(1);
                    }
                } else {
                    ((NettyHttpRequest) request).setBody(message);
                    s.request(1);
                }
            }

            @Override
            protected void doOnError(Throwable t) {
                try {
                    s.cancel();
                    exceptionCaught(context, t);
                } catch (Exception e) {
                    // should never happen
                    writeDefaultErrorResponse(context, request, e);
                }
            }

            @Override
            protected void doOnComplete() {
                for (UnicastProcessor subject: subjects.values()) {
                    if (!subject.hasComplete()) {
                        subject.onComplete();
                    }
                }
                executeRoute();
            }

            private void executeRoute() {
                if (executed.compareAndSet(false, true)) {
                    try {
                        routeMatch = prepareRouteForExecution(routeMatch, request);
                        routeMatch.execute();
                    } catch (Exception e) {
                        context.pipeline().fireExceptionCaught(e);
                    }
                }
            }
        };
    }
}