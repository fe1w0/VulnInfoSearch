class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {
    private static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);
    private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(
    private static final Argument ARGUMENT_PART_DATA = Argument.of(PartData.class);
    private final Router router;
    private final ExecutorSelector executorSelector;
    private final StaticResourceResolver staticResourceResolver;
    private final ExecutorService ioExecutor;
    private final BeanLocator beanLocator;
    private final NettyHttpServerConfiguration serverConfiguration;
    private final RequestArgumentSatisfier requestArgumentSatisfier;
    private final MediaTypeCodecRegistry mediaTypeCodecRegistry;
    private final NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry;
    private void handleStatusError(
            ChannelHandlerContext ctx,
            HttpRequest<?> request,
            NettyHttpRequest nettyHttpRequest,
            MutableHttpResponse<Object> defaultResponse,
            String message) {
        Optional<RouteMatch<Object>> statusRoute = router.route(defaultResponse.status());
        if (statusRoute.isPresent()) {
            RouteMatch<Object> routeMatch = statusRoute.get();
            handleRouteMatch(routeMatch, nettyHttpRequest, ctx);
        } else {

            if (HttpMethod.permitsRequestBody(request.getMethod())) {
                JsonError error = newError(request, message);
                defaultResponse.body(error);
            }


            AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(request);
            Flowable<? extends MutableHttpResponse<?>> responsePublisher = filterPublisher(
                    requestReference,
                    Flowable.just(defaultResponse),
                    ctx.channel().eventLoop(),
                    false
            );
            subscribeToResponsePublisher(
                    ctx,
                    MediaType.APPLICATION_JSON_TYPE,
                    requestReference,
                    responsePublisher
            );
        }
    }
}