class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {
    public static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);
    public static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(
    public static final Argument ARGUMENT_PART_DATA = Argument.of(PartData.class);
    public final Router router;
    public final ExecutorSelector executorSelector;
    public final StaticResourceResolver staticResourceResolver;
    public final ExecutorService ioExecutor;
    public final BeanLocator beanLocator;
    public final NettyHttpServerConfiguration serverConfiguration;
    public final RequestArgumentSatisfier requestArgumentSatisfier;
    public final MediaTypeCodecRegistry mediaTypeCodecRegistry;
    public final NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry;
    public void exceptionCaughtInternal(ChannelHandlerContext ctx,
                                         Throwable cause,
                                         NettyHttpRequest nettyHttpRequest,
                                         boolean nettyException) {
        RouteMatch<?> errorRoute = null;
        // find the origination of of the route
        RouteMatch<?> originalRoute = nettyHttpRequest.getMatchedRoute();
        Class declaringType = null;
        if (originalRoute instanceof MethodExecutionHandle) {
            declaringType = ((MethodExecutionHandle) originalRoute).getDeclaringType();
        }

        // when arguments do not match, then there is UnsatisfiedRouteException, we can handle this with a routed bad request
        if (cause instanceof UnsatisfiedRouteException) {
            if (declaringType != null) {
                // handle error with a method that is non global with bad request
                errorRoute = router.route(declaringType, HttpStatus.BAD_REQUEST).orElse(null);
            }
            if (errorRoute == null) {
                // handle error with a method that is global with bad request
                errorRoute = router.route(HttpStatus.BAD_REQUEST).orElse(null);
            }
        } else if (cause instanceof HttpStatusException) {
            HttpStatusException statusException = (HttpStatusException) cause;
            if (declaringType != null) {
                // handle error with a method that is non global with bad request
                errorRoute = router.route(declaringType, statusException.getStatus()).orElse(null);
            }
            if (errorRoute == null) {
                // handle error with a method that is global with bad request
                errorRoute = router.route(statusException.getStatus()).orElse(null);
            }
        } else if (cause instanceof BeanInstantiationException && declaringType != null) {
            // If the controller could not be instantiated, don't look for a local error route
            Optional<Class> rootBeanType = ((BeanInstantiationException) cause).getRootBeanType().map(BeanType::getBeanType);
            if (rootBeanType.isPresent() && declaringType == rootBeanType.get()) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug("Failed to instantiate [{}]. Skipping lookup of a local error route", declaringType.getName());
                }
                declaringType = null;
            }
        }

        // any another other exception may arise. handle these with non global exception marked method or a global exception marked method.
        if (errorRoute == null) {
            if (declaringType != null) {
                errorRoute = router.route(declaringType, cause).orElse(null);
            }
            if (errorRoute == null) {
                errorRoute = router.route(cause).orElse(null);
            }
        }

        if (errorRoute != null) {

            if (LOG.isDebugEnabled()) {
                LOG.debug("Found matching exception handler for exception [{}]: {}", cause.getMessage(), errorRoute);
            }
            errorRoute = requestArgumentSatisfier.fulfillArgumentRequirements(errorRoute, nettyHttpRequest, false);
            MediaType defaultResponseMediaType = errorRoute.getProduces().stream().findFirst().orElse(MediaType.APPLICATION_JSON_TYPE);
            try {
                final MethodBasedRouteMatch<?, ?> methodBasedRoute = (MethodBasedRouteMatch) errorRoute;
                Class<?> javaReturnType = errorRoute.getReturnType().getType();
                boolean isFuture = CompletionStage.class.isAssignableFrom(javaReturnType);
                boolean isReactiveReturnType = Publishers.isConvertibleToPublisher(javaReturnType) || isFuture;
                Flowable resultFlowable = Flowable.defer(() -> {
                      Object result = methodBasedRoute.execute();
                      MutableHttpResponse<?> response = errorResultToResponse(result);
                      response.setAttribute(HttpAttributes.ROUTE_MATCH, methodBasedRoute);
                      return Flowable.just(response);
                });

                AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(nettyHttpRequest);
                Flowable<MutableHttpResponse<?>> routePublisher = buildRoutePublisher(
                        methodBasedRoute.getDeclaringType(),
                        methodBasedRoute.getReturnType(),
                        isReactiveReturnType,
                        methodBasedRoute.getAnnotationMetadata(),
                        requestReference,
                        resultFlowable);

                Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(
                        requestReference,
                        routePublisher,
                        ctx.channel().eventLoop(),
                        nettyException);

                subscribeToResponsePublisher(
                        ctx,
                        defaultResponseMediaType,
                        requestReference,
                        filteredPublisher
                );

                if (serverConfiguration.isLogHandledExceptions()) {
                    logException(cause);
                }

            } catch (Throwable e) {
                if (LOG.isErrorEnabled()) {
                    LOG.error("Exception occurred executing error handler. Falling back to default error handling: " + e.getMessage(), e);
                }
                writeDefaultErrorResponse(ctx, nettyHttpRequest, e);
            }
        } else {

            Optional<ExceptionHandler> exceptionHandler = beanLocator
                    .findBean(ExceptionHandler.class, Qualifiers.byTypeArgumentsClosest(cause.getClass(), Object.class));

            if (exceptionHandler.isPresent()) {
                ExceptionHandler handler = exceptionHandler.get();
                MediaType defaultResponseMediaType = MediaType.fromType(handler.getClass()).orElse(MediaType.APPLICATION_JSON_TYPE);
                try {
                    Flowable resultFlowable = Flowable.defer(() -> {
                        Object result = handler.handle(nettyHttpRequest, cause);
                        MutableHttpResponse<?> response = errorResultToResponse(result);
                        return Flowable.just(response);
                    });

                    AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(nettyHttpRequest);
                    Flowable<MutableHttpResponse<?>> routePublisher = buildRoutePublisher(
                            handler.getClass(),
                            ReturnType.of(HttpResponse.class),
                            false,
                            AnnotationMetadata.EMPTY_METADATA,
                            requestReference,
                            resultFlowable);

                    Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(
                            requestReference,
                            routePublisher,
                            ctx.channel().eventLoop(),
                            nettyException);

                    subscribeToResponsePublisher(
                            ctx,
                            defaultResponseMediaType,
                            requestReference,
                            filteredPublisher
                    );

                    if (serverConfiguration.isLogHandledExceptions()) {
                        logException(cause);
                    }
                } catch (Throwable e) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug("Exception occurred executing error handler. Falling back to default error handling.");
                    }
                    writeDefaultErrorResponse(ctx, nettyHttpRequest, e);
                }
            } else {
                logException(cause);

                Flowable resultFlowable = Flowable.defer(() ->
                        Flowable.just(HttpResponse.serverError().body(new JsonError("Internal Server Error: " + cause.getMessage())))
                );

                AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(nettyHttpRequest);
                Flowable<MutableHttpResponse<?>> routePublisher = buildRoutePublisher(
                        null,
                        ReturnType.of(HttpResponse.class),
                        false,
                        AnnotationMetadata.EMPTY_METADATA,
                        requestReference,
                        resultFlowable);

                Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(
                        requestReference,
                        routePublisher,
                        ctx.channel().eventLoop(),
                        nettyException);

                subscribeToResponsePublisher(
                        ctx,
                        MediaType.APPLICATION_JSON_TYPE,
                        requestReference,
                        filteredPublisher
                );
            }
        }
    }
}