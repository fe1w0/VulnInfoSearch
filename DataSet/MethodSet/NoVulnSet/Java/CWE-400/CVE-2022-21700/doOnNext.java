protected void doOnNext(Object message) {
    boolean executed = this.executed.get();
    if (message instanceof ByteBufHolder) {
        if (message instanceof HttpData) {
            HttpData data = (HttpData) message;

            if (LOG.isTraceEnabled()) {
                LOG.trace("Received HTTP Data for request [{}]: {}", request, message);
            }

            String name = data.getName();
            Optional<Argument<?>> requiredInput = routeMatch.getRequiredInput(name);

            if (requiredInput.isPresent()) {
                Argument<?> argument = requiredInput.get();
                Supplier<Object> value;
                boolean isPublisher = Publishers.isConvertibleToPublisher(argument.getType());
                boolean chunkedProcessing = false;

                if (isPublisher) {
                    Integer dataKey = System.identityHashCode(data);
                    HttpDataReference dataReference = dataReferences.computeIfAbsent(dataKey, (key) -> {
                        return new HttpDataReference(data);
                    });
                    Argument typeVariable;

                    if (StreamingFileUpload.class.isAssignableFrom(argument.getType())) {
                        typeVariable = ARGUMENT_PART_DATA;
                    } else {
                        typeVariable = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
                    }
                    Class typeVariableType = typeVariable.getType();

                    UnicastProcessor namedSubject = subjects.computeIfAbsent(name, (key) -> UnicastProcessor.create());

                    chunkedProcessing = PartData.class.equals(typeVariableType) ||
                            Publishers.isConvertibleToPublisher(typeVariableType) ||
                            ClassUtils.isJavaLangType(typeVariableType);

                    if (Publishers.isConvertibleToPublisher(typeVariableType)) {
                        boolean streamingFileUpload = StreamingFileUpload.class.isAssignableFrom(typeVariableType);
                        if (streamingFileUpload) {
                            typeVariable = ARGUMENT_PART_DATA;
                        } else {
                            typeVariable = typeVariable.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
                        }
                        dataReference.subject.getAndUpdate(subject -> {
                            if (subject == null) {
                                UnicastProcessor childSubject = UnicastProcessor.create();
                                Flowable flowable = processFlowable(childSubject, dataKey, true);
                                if (streamingFileUpload && data instanceof FileUpload) {
                                    namedSubject.onNext(new NettyStreamingFileUpload(
                                            (FileUpload) data,
                                            serverConfiguration.getMultipart(),
                                            ioExecutor,
                                            flowable));
                                } else {
                                    namedSubject.onNext(flowable);
                                }

                                return childSubject;
                            }
                            return subject;
                        });

                    }

                    UnicastProcessor subject = Optional.ofNullable(dataReference.subject.get()).orElse(namedSubject);

                    Object part = data;

                    if (chunkedProcessing) {
                        HttpDataReference.Component component = dataReference.addComponent((e) -> {
                            subject.onError(e);
                            s.cancel();
                        });
                        if (component == null) {
                            return;
                        }
                        part = new NettyPartData(dataReference, component);
                    }

                    if (data instanceof FileUpload &&
                            StreamingFileUpload.class.isAssignableFrom(argument.getType())) {
                        dataReference.upload.getAndUpdate(upload -> {
                            if (upload == null) {
                                return new NettyStreamingFileUpload(
                                        (FileUpload) data,
                                        serverConfiguration.getMultipart(),
                                        ioExecutor,
                                        processFlowable(subject, dataKey, true));
                            }
                            return upload;
                        });
                    }

                    Optional<?> converted = conversionService.convert(part, typeVariable);

                    converted.ifPresent(subject::onNext);

                    if (data.isCompleted() && chunkedProcessing) {
                        subject.onComplete();
                    }

                    value = () -> {
                        StreamingFileUpload upload = dataReference.upload.get();
                        if (upload != null) {
                            return upload;
                        } else {
                            return processFlowable(namedSubject, dataKey, dataReference.subject.get() == null);
                        }
                    };

                } else {
                    if (data instanceof Attribute && !data.isCompleted()) {
                        request.addContent(data);
                        s.request(1);
                        return;
                    } else {
                        value = () -> {
                            if (data.refCnt() > 0) {
                                return data;
                            } else {
                                return null;
                            }
                        };
                    }
                }

                if (!executed) {
                    String argumentName = argument.getName();
                    if (!routeMatch.isSatisfied(argumentName)) {
                        routeMatch = routeMatch.fulfill(Collections.singletonMap(argumentName, value.get()));
                    }
                    if (isPublisher && chunkedProcessing) {
                        //accounting for the previous request
                        pressureRequested.incrementAndGet();
                    }
                    if (routeMatch.isExecutable() || message instanceof LastHttpContent) {
                        executeRoute();
                        executed = true;
                    }
                }

                if (alwaysAddContent) {
                    request.addContent(data);
                }

                if (!executed || !chunkedProcessing) {
                    s.request(1);
                }

            } else {
                request.addContent(data);
                s.request(1);
            }
        } else {
            request.addContent((ByteBufHolder) message);
            s.request(1);
        }
    } else {