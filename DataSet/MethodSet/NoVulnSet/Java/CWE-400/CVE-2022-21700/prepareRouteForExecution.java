class RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {
    private static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);
    private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(
    private static final Argument ARGUMENT_PART_DATA = Argument.of(PartData.class);
    private final Router router;
    private final ExecutorSelector executorSelector;
    private final StaticResourceResolver staticResourceResolver;
    private final ExecutorService ioExecutor;
    private final BeanLocator beanLocator;
    private final NettyHttpServerConfiguration serverConfiguration;
    private final RequestArgumentSatisfier requestArgumentSatisfier;
    private final MediaTypeCodecRegistry mediaTypeCodecRegistry;
    private final NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry;
    public RouteMatch<?> prepareRouteForExecution(RouteMatch<?> route, NettyHttpRequest<?> request) {
        ChannelHandlerContext context = request.getChannelHandlerContext();
        // Select the most appropriate Executor
        ExecutorService executor;
        if (route instanceof MethodBasedRouteMatch) {
            executor = executorSelector.select((MethodBasedRouteMatch) route).orElse(context.channel().eventLoop());
        } else {
            executor = context.channel().eventLoop();
        }

        route = route.decorate(finalRoute -> {
            MediaType defaultResponseMediaType = finalRoute
                .getProduces()
                .stream()
                .findFirst()
                .orElse(MediaType.APPLICATION_JSON_TYPE);


            ReturnType<?> genericReturnType = finalRoute.getReturnType();
            Class<?> javaReturnType = genericReturnType.getType();

            AtomicReference<io.micronaut.http.HttpRequest<?>> requestReference = new AtomicReference<>(request);
            boolean isFuture = CompletionStage.class.isAssignableFrom(javaReturnType);
            boolean isReactiveReturnType = Publishers.isConvertibleToPublisher(javaReturnType) || isFuture;
            boolean isSingle =
                    isReactiveReturnType && Publishers.isSingle(javaReturnType) ||
                            isResponsePublisher(genericReturnType, javaReturnType) ||
                                isFuture ||
                                    finalRoute.getAnnotationMetadata().booleanValue(Produces.class, "single").orElse(false);

            // build the result emitter. This result emitter emits the response from a controller action
            Flowable<?> resultEmitter = buildResultEmitter(
                    context,
                    finalRoute,
                    requestReference,
                    isReactiveReturnType,
                    isSingle
            );

            // here we transform the result of the controller action into a MutableHttpResponse
            Flowable<MutableHttpResponse<?>> routePublisher = resultEmitter.map((message) -> {
                RouteMatch<?> routeMatch = finalRoute;
                MutableHttpResponse<?> finalResponse = messageToResponse(routeMatch, message);
                if (requestReference.get().getMethod().equals(HttpMethod.HEAD)) {
                    finalResponse.getBody()
                            .filter(ReferenceCounted.class::isInstance)
                            .map(ReferenceCounted.class::cast)
                            .ifPresent(ReferenceCounted::release);
                    finalResponse.body(null);
                }
                HttpStatus status = finalResponse.getStatus();

                if (status.getCode() >= HttpStatus.BAD_REQUEST.getCode()) {
                    Class declaringType = ((MethodBasedRouteMatch) routeMatch).getDeclaringType();
                    // handle re-mapping of errors
                    Optional<RouteMatch<Object>> statusRoute = Optional.empty();
                    // if declaringType is not null, this means its a locally marked method handler
                    if (declaringType != null) {
                        statusRoute = router.route(declaringType, status);
                    }
                    if (!statusRoute.isPresent()) {
                        statusRoute = router.route(status);
                    }
                    io.micronaut.http.HttpRequest<?> httpRequest = requestReference.get();

                    if (statusRoute.isPresent()) {
                        routeMatch = statusRoute.get();
                        httpRequest.setAttribute(HttpAttributes.ROUTE_MATCH, routeMatch);

                        routeMatch = requestArgumentSatisfier.fulfillArgumentRequirements(routeMatch, httpRequest, true);

                        if (routeMatch.isExecutable()) {
                            Object result;
                            try {
                                result = routeMatch.execute();
                                finalResponse = messageToResponse(routeMatch, result);
                            } catch (Throwable e) {
                                throw new InternalServerException("Error executing status route [" + routeMatch + "]: " + e.getMessage(), e);
                            }
                        } else {
                            if (LOG.isWarnEnabled()) {
                                LOG.warn("Matched status route [" + routeMatch + "] not executed because one or more arguments could not be bound. Returning the original response.");
                            }
                        }
                    }

                }
                finalResponse.setAttribute(HttpAttributes.ROUTE_MATCH, routeMatch);
                return finalResponse;
            });

            routePublisher = buildRoutePublisher(
                    finalRoute.getDeclaringType(),
                    genericReturnType,
                    isReactiveReturnType,
                    finalRoute.getAnnotationMetadata(),
                    requestReference,
                    routePublisher
            );

            // process the publisher through the available filters
            Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(
                    requestReference,
                    routePublisher,
                    executor,
                    false
            );

            boolean isStreaming = isReactiveReturnType && !isSingle;

            Optional<Class<?>> javaPayloadType = genericReturnType.getFirstTypeVariable().map(arg -> arg.getType());

            if (!isStreaming) {
                if (HttpResponse.class.isAssignableFrom(javaReturnType)) {
                    Optional<Argument<?>> generic = genericReturnType.getFirstTypeVariable();
                    if (generic.isPresent()) {
                        // Unwrap response type information
                        Class genericType = generic.get().getType();
                        isStreaming = Publishers.isConvertibleToPublisher(genericType) && !Publishers.isSingle(genericType);

                        if (isStreaming) {
                            javaPayloadType = generic.get().getFirstTypeVariable().map(Argument::getType);
                        }
                    }
                }
            }

            Class finalJavaPayloadType = javaPayloadType.orElse(Object.class);
            boolean finalIsStreaming = isStreaming;
            filteredPublisher  = filteredPublisher.switchMap((response) -> {
                Optional<?> responseBody = response.getBody();
                if (responseBody.isPresent()) {
                    Object body = responseBody.get();
                    if (finalIsStreaming) {
                        // handled downstream
                        return Flowable.just(response);
                    } else if (Publishers.isConvertibleToPublisher(body)) {
                        Flowable<?> bodyFlowable = Publishers.convertPublisher(body, Flowable.class);
                        Flowable<MutableHttpResponse<?>> bodyToResponse = bodyFlowable.map((bodyContent) ->
                                setBodyContent(response, bodyContent)
                        );
                        return bodyToResponse.switchIfEmpty(Flowable.just(response));
                    }
                }

                return Flowable.just(response);
            });

            if (!isStreaming) {
                subscribeToResponsePublisher(context, defaultResponseMediaType, requestReference, filteredPublisher);
            } else {
                filteredPublisher.subscribe(new ContextCompletionAwareSubscriber<MutableHttpResponse<?>>(context) {
                    @Override
                    protected void onComplete(MutableHttpResponse<?> response) {
                        Optional<?> responseBody = response.getBody();
                        @SuppressWarnings("unchecked")
                        Flowable<Object> bodyFlowable = responseBody.map(o -> Publishers.convertPublisher(o, Flowable.class)).orElse(Flowable.empty());

                        NettyMutableHttpResponse nettyHttpResponse = (NettyMutableHttpResponse) response;
                        FullHttpResponse nettyResponse = nettyHttpResponse.getNativeResponse();
                        Optional<MediaType> specifiedMediaType = response.getContentType();
                        MediaType responseMediaType = specifiedMediaType.orElse(defaultResponseMediaType);

                        applyConfiguredHeaders(response.getHeaders());

                        boolean isJson = responseMediaType.getExtension().equals(MediaType.EXTENSION_JSON) &&
                                isJsonFormattable(finalJavaPayloadType);

                        streamHttpContentChunkByChunk(
                                context,
                                request,
                                nettyResponse,
                                responseMediaType,
                                isJson,
                                bodyFlowable);
                    }
                });
            }

            return null;
        });
        return route;
    }
}