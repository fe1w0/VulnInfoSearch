public class OpcTcpServer extends AbstractState<CloseableObjectState, ServiceResultException> implements EndpointServer {
	static Logger logger = LoggerFactory.getLogger(OpcTcpServer.class);
	Application application;
	AtomicInteger secureChannelCounter = new AtomicInteger();
	EndpointBindingCollection endpointBindings = new EndpointBindingCollection(); 
	public Server discoveryServer;
	public EndpointBinding discoveryEndpointBinding;
	private int receiveBufferSize = 0;
	private boolean initialized = false;
	Map<SocketAddress, SocketHandle> socketHandles = new HashMap<SocketAddress, SocketHandle>();
	org.opcfoundation.ua.utils.asyncsocket.AsyncServerSocket.ConnectListener connectListener = new org.opcfoundation.ua.utils.asyncsocket.AsyncServerSocket.ConnectListener() {		
	ConnectionCollection connections = new ConnectionCollection(this);	
	int maxConnections;
	int maxSecureChannelsPerConnection;	
	public void bindReverse(final SocketAddress addressToConnect,
			final String endpointUrl) {
		if(addressToConnect == null || endpointUrl == null) {
			throw new IllegalArgumentException();
		}
		init();
		
		ReverseSocketHandle socketHandle = new ReverseSocketHandle(addressToConnect);
		if(socketHandle.socket == null) {
			try {
				socketHandle.setChannel(SocketChannel.open());
				socketHandle.getChannel().configureBlocking(false);
				
				socketHandle.socket = new AsyncSocketImpl(socketHandle.getChannel(), StackUtils.getNonBlockingWorkExecutor(), StackUtils.getSelector());

				ReverseHello rh = new ReverseHello();
				rh.setEndpointUrl(endpointUrl);
				rh.setServerUri(application.getApplicationDescription().getApplicationUri());
				final OpcTcpServerConnection conn = new OpcTcpServerConnection(OpcTcpServer.this, socketHandle.socket, rh); 
				connections.addConnection(conn);
				
				conn.addConnectionListener(new IConnectionListener() {
					@Override
					public void onClosed(ServiceResultException closeError) {						
						connections.removeConnection(conn);
							
						//1.04 Part 6 section 7.1.3 when closed, server must restart the process
						logger.debug("ReverseHello connection closed, rescheduling connection process");
						bindReverse(addressToConnect, endpointUrl);
					}
					@Override
					public void onOpen() {
					}});
		        // start listening to messages
				conn.init();
				//async, do last, others listen on socket state.
				socketHandle.socket.connect(socketHandle.socketAddress);
			}catch(IOException e) {
				logger.error("Failed to create a ReverseSocketHandle", e);
				socketHandle.close();
			}
			
		}

	}
}