		public void onConnected(AsyncServerSocket sender, AsyncSocketImpl newConnection) {
			logger.info("{}: {} connected", OpcTcpServer.this, newConnection.socket().getRemoteSocketAddress());
			final OpcTcpServerConnection conn = new OpcTcpServerConnection(OpcTcpServer.this, newConnection);
			connections.addConnection(conn);
			
			conn.addConnectionListener(new IConnectionListener() {
				@Override
				public void onClosed(ServiceResultException closeError) {						
						connections.removeConnection(conn);
				}
				@Override
				public void onOpen() {
				}});
			
	          // Check for connection count limits
	          // Per 1.05 Part 4 section 5.5.2, To protect against misbehaving Clients and denial of
	          // service attacks, the Server shall close the oldest unused SecureChannelthat has no
	          // Session assigned before reaching the maximum number of supported SecureChannels.


	          List<ServerConnection> conns = new ArrayList<ServerConnection>();
	          connections.getConnections(conns);

	          logger.trace("Checking maximum number of connections, limit: {}, current: {}", maxConnections, conns.size());

	          // at limit is enough per the 5.5.2
	          if (conns.size() >= maxConnections) {
	            int delta = maxConnections - conns.size() + 1;
	            logger.trace("We are at max or over limit, number of connections to purge if possible: {}", delta);
	            // TODO ordering based on timestamps of creation
	            int purged = 0;
	            for (ServerConnection tmp : conns) {
	              if (tmp instanceof OpcTcpServerConnection) {
	                // Every connection should be of this type in this OpcTcpServer)
	                OpcTcpServerConnection opcTcpTmp = (OpcTcpServerConnection) tmp;

	                // We are itself part of the connections as well. Skip ourselves here (that is
	                // handled at the end of this method). If we remove ourselves here, and would be the
	                // "final legit" connection (and then we would be at max capacity), we would be
	                // closed before we can ActivateSession.
	                if (conn == opcTcpTmp) {
	                  continue;
	                }

	                if (opcTcpTmp.isPurgeEligible()) {
	                  opcTcpTmp.close();
	                  purged++;
	                  if (purged >= delta) {
	                    break;
	                  }
	                }
	              }
	            }
	            logger.trace("We are at max or over limit, purged {} old connections", purged);
	          }
	          // It is possible that we were not able to purge anything, if we happen to be at max
	          // connections that all have activated sessions, in this case, close this connection
	          // instead.
	          List<ServerConnection> tmp = new ArrayList<ServerConnection>();
	          connections.getConnections(tmp);
	          /*
	           * But! This connection itself is within the connections, if we are exactly at max, that
	           * is still OK here. But if we are over (i.e. we already had at max and none cannot be
	           * removed), then remove this connection.
	           */
	          if (tmp.size() > maxConnections) {
	            logger.trace("We are at over limit, unable to purge enough old connections, closing this connection");
	            conn.close();
	          } else {