public class OpcTcpServerConnection extends AbstractServerConnection {
	private final static Logger logger = LoggerFactory.getLogger(OpcTcpServerConnection.class);
	private static long handshakeTimeout = 10 * 60 * 1000; // 10 minutes
	int agreedProtocolVersion;
	Map<Integer, PendingRequest> pendingRequests  = new ConcurrentHashMap<Integer, PendingRequest>();
	EndpointBinding binding;
	OpcTcpServer endpointServer;
	AsyncSocket s;
	ReverseHello rh;
	AtomicBoolean hasBeenSuccessfullySessionActivated = new AtomicBoolean(false);
	Timer timer = TimerUtil.getTimer();
	TimerTask timeoutTimer;
	Runnable timeout = new Runnable() {
		EncoderContext encoderCtx;
		EndpointConfiguration endpointConfiguration;
		MonitorListener inputListener =
		MessageListener messageListener = new MessageListener() {
			public void init() {
				s.getStateMonitor().addStateListener(socketListener);
				
			    // must set timeout timer here, because it might be canceled before the below monitor
			    // is triggered
				if(rh == null) {
					timeoutTimer = TimerUtil.schedule(
							timer, timeout,
							StackUtils.getBlockingWorkExecutor(),
							System.currentTimeMillis() + handshakeTimeout);
				}

			    // Start listening for the Hello (the inputListener will schedule itself again)
				s.getInputStream().createMonitor(8, inputListener);

				if(rh != null) {
					s.getStateMonitor().addStateListener(new StateListener<SocketState>() {
						@Override
						public void onStateTransition(
								IStatefulObject<SocketState, ?> sender,
								SocketState oldState, SocketState newState) {
							if(oldState == SocketState.Connecting && newState == SocketState.Connected) {
								timeoutTimer = TimerUtil.schedule(
										timer, timeout,
										StackUtils.getBlockingWorkExecutor(),
										System.currentTimeMillis() + handshakeTimeout);
								sendReverseHello(rh);
							}							
						}
					});
				}	
			  }			
}