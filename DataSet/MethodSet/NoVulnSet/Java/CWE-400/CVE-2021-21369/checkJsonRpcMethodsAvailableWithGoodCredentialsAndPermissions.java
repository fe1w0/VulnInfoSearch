public class JsonRpcHttpServiceLoginTest {
  @ClassRule public static final TemporaryFolder folder = new TemporaryFolder();
  public static final Vertx vertx = Vertx.vertx();
  public static Map<String, JsonRpcMethod> rpcMethods;
  public static JsonRpcHttpService service;
  public static OkHttpClient client;
  public static String baseUrl;
  public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
  public static final String CLIENT_VERSION = "TestClientVersion/0.1.0";
  public static final BigInteger CHAIN_ID = BigInteger.valueOf(123);
  public static P2PNetwork peerDiscoveryMock;
  public static BlockchainQueries blockchainQueries;
  public static Synchronizer synchronizer;
  public static final Collection<RpcApi> JSON_RPC_APIS =
  public static JWTAuth jwtAuth;
  public static String authPermissionsConfigFilePath = "JsonRpcHttpService/auth.toml";
  public final JsonRpcTestHelper testHelper = new JsonRpcTestHelper();
  public static final NatService natService = new NatService(Optional.empty());
  public void checkJsonRpcMethodsAvailableWithGoodCredentialsAndPermissions() throws IOException {
    final RequestBody body =
        RequestBody.create(JSON, "{\"username\":\"user\",\"password\":\"pegasys\"}");
    final Request request = new Request.Builder().post(body).url(baseUrl + "/login").build();
    try (final Response resp = client.newCall(request).execute()) {
      assertThat(resp.code()).isEqualTo(200);
      assertThat(resp.message()).isEqualTo("OK");
      assertThat(resp.body().contentType()).isNotNull();
      assertThat(resp.body().contentType().type()).isEqualTo("application");
      assertThat(resp.body().contentType().subtype()).isEqualTo("json");
      final String bodyString = resp.body().string();
      assertThat(bodyString).isNotNull();
      assertThat(bodyString).isNotBlank();

      final JsonObject respBody = new JsonObject(bodyString);
      final String token = respBody.getString("token");
      assertThat(token).isNotNull();

      final JsonRpcMethod ethAccounts = new EthAccounts();
      final JsonRpcMethod netVersion = new NetVersion(Optional.of(BigInteger.valueOf(123)));
      final JsonRpcMethod ethBlockNumber = new EthBlockNumber(blockchainQueries);
      final JsonRpcMethod web3Sha3 = new Web3Sha3();
      final JsonRpcMethod web3ClientVersion = new Web3ClientVersion("777");

      jwtAuth.authenticate(
          new JsonObject().put("jwt", token),
          (r) -> {
            assertThat(r.succeeded()).isTrue();
            final User user = r.result();
            // single eth/blockNumber method permitted
            Assertions.assertThat(
                    AuthenticationUtils.isPermitted(
                        service.authenticationService, Optional.of(user), ethBlockNumber))
                .isTrue();
            // eth/accounts NOT permitted
            assertThat(
                    AuthenticationUtils.isPermitted(
                        service.authenticationService, Optional.of(user), ethAccounts))
                .isFalse();
            // allowed by web3/*
            assertThat(
                    AuthenticationUtils.isPermitted(
                        service.authenticationService, Optional.of(user), web3ClientVersion))
                .isTrue();
            assertThat(
                    AuthenticationUtils.isPermitted(
                        service.authenticationService, Optional.of(user), web3Sha3))
                .isTrue();
            // NO net permissions
            assertThat(
                    AuthenticationUtils.isPermitted(
                        service.authenticationService, Optional.of(user), netVersion))
                .isFalse();
          });
    }
  }
}